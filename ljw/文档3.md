# 文档

# 格式 1 删除

1： x 为删除单个字符

2： X 为删除单个字符

3：  diw 为删除光标所在的单词

4：  D 为删除行

5：dd 为删除行

# 格式 2 修改

1;  s 修改行

2;  i 在光标前插入行

3; a 在光标后插入行

4;  C 修改行尾

# 格式 3撤销

1; u 撤销命令

2；Ctrl-r 重新座

#  格式 4 复制

1；p 命令粘贴到光标之前

2；P 命令粘贴到光标之后

3； yy 复制

4； V 可视化

5；n yy p   复制n行  

# 格式4 显示行数和隐藏行数

1；set nu  显示行数

2；set nu! 隐藏行数

# 格式 5 移动和注释

1；[] 移动到代码块开头

2;   ][ 移动到代码块末尾

3;   ]} 跳转到代码尾部

4； nG 移动到n行

5；gg和G 顶部和底部

# 格式 6 执行

1; zfap 折一段文字

2； zf 创建折行

3；zo 打开折行

4；zc 关闭折行

# 格式 7 保存和退出

1     :w 保存

2      :wq/ZZ/:x 保存推出

3      :q!   不保存退出

# git论坛账号申请和仓库的建立

### Linux 平台上安装

1；http://git-scm.com/downloads

2；Debian/Ubuntu

Debian/Ubuntu Git 安装命令为：

```
$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev

$ apt-get install git

$ git --version
git version 1.8.1.2
```

### Centos/RedHat

如果你使用的系统是 Centos/RedHat 安装命令为：

```
$ yum install curl-devel expat-devel gettext-devel \
  openssl-devel zlib-devel

$ yum -y install git-core

$ git --version
git version 1.7.1
```

### 源码安装

我们也可以在官网下载源码包来安装，最新源码包下载地址：https://git-scm.com/download

安装指定系统的依赖包：

```
########## Centos/RedHat ##########
$ yum install curl-devel expat-devel gettext-devel \
  openssl-devel zlib-devel

########## Debian/Ubuntu ##########
$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev
```

解压安装下载的源码包：

```
$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install
```

3；Windows 平台上安装

在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：

安装包下载地址：https://gitforwindows.org/

![Windows 上安装 Git](https://www.runoob.com/wp-content/uploads/2015/02/20140127131250906)

在开始菜单里找到"Git"->"Git Bash"，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。

4；Mac 平台上安装

在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：

http://sourceforge.net/projects/git-osx-installer/

安装界面如下所示：



![18333fig0107-tn](https://www.runoob.com/wp-content/uploads/2015/02/18333fig0107-tn.png)

### Git 配置

Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。

这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

- `/etc/gitconfig` 文件：系统中对所有用户都普遍适用的配置。若使用 `git config` 时用 `--system` 选项，读写的就是这个文件。
- `~/.gitconfig` 文件：用户目录下的配置文件只适用于该用户。若使用 `git config` 时用 `--global` 选项，读写的就是这个文件。
- 当前项目的 Git 目录中的配置文件（也就是工作目录中的 `.git/config` 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 `.git/config` 里的配置会覆盖 `/etc/gitconfig` 中的同名变量。

在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。

此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。

### 用户信息

配置个人的用户名称和电子邮件地址：

```
$ git config --global user.name "runoob"
$ git config --global user.email test@runoob.com
```

如果用了 **--global** 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。

如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。

### 文本编辑器

设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:

```
$ git config --global core.editor emacs
```

### 差异分析工具

还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：

```
$ git config --global merge.tool vimdiff
```

Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。

当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。

### 查看配置信息

要检查已有的配置信息，可以使用 git config --list 命令：

```
$ git config --list
http.postbuffer=2M
user.name=runoob
user.email=test@runoob.com
```

有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。

这些配置我们也可以在 **~/.gitconfig** 或 **/etc/gitconfig** 看到，如下所示：

```
vim ~/.gitconfig 
```

显示内容如下所示：

```
[http]
    postBuffer = 2M
[user]
    name = runoob
    email = test@runoob.com
```

也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：

```
$ git config user.name
runoob
```

## 仓库的建立

1;

2;

3;

4;

5;

6;

7;

8;



# git服务器记住密码命令

1；git config --global credential.helper store

# git的流程 

1；建立一个文件                        命令：mkdir 文件名

2：进入到这个文件下                命令： cd 为年命

3；建立一个文档                         命令： touch 文档名称

4；提交这个文档                         命令：git add 文件

5；给这个文档启用一个别名   命令：git commit -m  '别名名称'

6；如果重新建立一个库名 则需要重新登陆（在服务其中） 命令： git  remote add origin https://github.com/你的名字/你的库别名.git

7; 推送至分支内                            命令:    git push -u origin  你的分支名称

8；查看你的分支是哪一个        命令：git branch ;

9;    gti 建立一个分支        					 命令：git checkout -b  分支名称

10；删除一个分支    					命令：git branch -d 分支名称

11；将这个分支推送出去   		命令：git push origin 分支名称

12；更新你的仓库                        命令：git pull

13；合并分支                    			 命令：git  merge 分支名

14；将它们标记为合并成功：  命令：git add <filename>

15；在合并改动之前，你可以使用如下命令预览差异：命令：git diff <source_branch> <target_branch>

16；取提交 ID：                              命令：git log

17；换掉本地改动：                      命令：git checkout -- <filename>

18；获取最新的版本历史             命令：git fetch origin

19；更新你的 git fetch -a

20；合并你的  git merge origin  想合并的（特就是更新后最后面的信息）

21;     rm -rf  文件名 删除

22;    git status  查看是那个分支

23 ： git add .  在那个文件下 提交这个文件的所有内容

24：git push -u origin lwijunwei -f   使用：

出现以下情况To https://github.com/dawnlight-520/File.git
 ! [rejected]        lwijunwei -> lwijunwei (non-fast-forward)
error: 无法推送一些引用到 'https://github.com/dawnlight-520/File.git'
提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。
提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见
提示：'git push --help' 中的 'Note about fast-forwards' 小节。

例如图片显示：

![image-20191125110328970](/home/lei/.config/Typora/typora-user-images/image-20191125110328970.png)

# git  组员流程

## 步骤

1；建立自己的文件                命令  mkdir  文件名

2；进入到自己的文件下	   命令   cd  /

3；clone 别人的网址			命令   git clone 

4；ls 查看有那些目录			命令  ls

5；进入到他的目录下			命令  cd 别人的目录

6；建立自己的分支				命令   git checkout -b   分支名11

7；在自己的分支下上传你的文件		命令   git add  文件名

8；提交文件				命令  git commit -m   '别名'

9；推送到远程			命令   git push  -u  origin      分支名11:随意的别名

# git 组长流程

## 步骤

1；创建库:  mkdir 库名

2；打开库：cd 库名

3；设置为git仓库： git init

4；创建文件：touch 文件名

5；添加文件：git add 文件名（git add . 是添加全部文件）

6；提交+注释： git commit -m "注释"

7；git remoteadd origin ...

8；git push -u origin master

9；查看本地所以分支： git branch

10；在Git社区给组员发科隆连接并发送邮箱邀请

11；切换到新分支： git  checkout  -b 分支名

12；查看本地所以分支： git branch

13；创建库:  mkdir 库名

14；打开库：cd 库名

15；创建文件：touch 文件名

16；添加文件：git add 文件名（git add . 是添加全部文件）

17；提交+注释： git commit -m "注释"

18；推送自己的分支：git push origin 支名：支名

19；查看本地所以分支： git branch

20；将远程最新内容拉到本地：git fetch -a

21；一个一个合并：git merge origin/组员分支名

22；查看：ls

23；查看当前状态：git  status

24；切换到master分支：git checkout master

25；查看本地所以分支： git branch

26；在自己master中合并自己支名：git merge 支名（不是master分支，是你自己的分支）

27；查看本地所以分支： git branch

28；添加全部文件：git add .

29；提交+注释： git commit -m "注释"

30；推送的远程仓库：git push origin master:master

## 问题解答

## 当你要克隆你的开发分支时：命令为：git clone  -b  克隆网址。

图片：

![img](https://static.dingtalk.com/media/lADPDgQ9rQ3XYWPNC7jND6A_4000_3000.jpg?auth_bizType=IM&auth_bizEntity=%7B%22cid%22%3A%22616435591%3A616435591%22%2C%22msgId%22%3A%221879089987777%22%7D&bizType=im&open_id=616435591)

# 要命的事

lei@lei-ThinkPad-T420:~/雷军委/File$ git add zhouji
error: unable to index file zhouji
fatal: 更新文件失败
lei@lei-ThinkPad-T420:~/雷军委/File$ git rm zhouji
zhouji: needs merge未合并的路径：未合并的路径：
  （使用 "git add <文件>..." 标记解决方案）

￼
由他们添加： zhouji
未跟踪的文件:
  （使用 "git add <文件>..." 以包含要提交的内容）
  （使用 "git add <文件>..." 标记解决方案）

￼
由他们添加： zhouji
未跟踪的文件:
  （使用 "git add <文件>..." 以包含要提交的内容）
rm 'zhouji'
lei@lei-ThinkPad-T420:~/雷军委/File$ ls
1.md  hao  HCX  ljw  mxbj  mxx
lei@lei-ThinkPad-T420:~/雷军委/File$ git add mxx
lei@lei-ThinkPad-T420:~/雷军委/File$ git add mxx/
lei@lei-ThinkPad-T420:~/雷军委/File$ git commit -m "note"
[lwijunwei 02634d3] note
lei@lei-ThinkPad-T420:~/雷军委/File$ git push origin lwijunwei:lwijunwei
对象计数中: 2, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (2/2), 完成.
写入对象中: 100% (2/2), 276 bytes | 276.00 KiB/s, 完成.
Total 2 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/dawnlight-520/File.git
   3d567df..02634d3  lwijunwei -> lwijunwei
lei@lei-ThinkPad-T420:~/雷军委/File$ git merge lwijunwei
已经是最新的。
lei@lei-ThinkPad-T420:~/雷军委/File$ git branch

* lwijunwei
  master
  zj
lei@lei-ThinkPad-T420:~/雷军委/File$ git checkout master
切换到分支 'master'
您的分支领先 'origin/master' 共 4 个提交。
  （使用 "git push" 来发布您的本地提交）
lei@lei-ThinkPad-T420:~/雷军委/File$ git merge lwijunwei
更新 353d327..02634d3
Fast-forward
 zhouji        |  1 -
 zhouji/zzj.md | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 68 insertions(+), 1 deletion(-)
 delete mode 160000 zhouji
 create mode 100644 zhouji/zzj.md
lei@lei-ThinkPad-T420:~/雷军委/File$ git add .
lei@lei-ThinkPad-T420:~/雷军委/File$ git commit -m "note"
[master 07a1f87] note
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 .gitignore
lei@lei-ThinkPad-T420:~/雷军委/File$ git push origin master:master
对象计数中: 3, 完成.
Delta compression using up to 4 threads.
压缩对象中: 100% (2/2), 完成.
写入对象中: 100% (3/3), 263 bytes | 263.00 KiB/s, 完成.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
To https://github.com/dawnlight-520/File.git
   d426f1b..07a1f87  master -> master
lei@lei-ThinkPad-T420:~/雷军委/File$ 

## 出现这个问题可以先删除这个

未合并的路径：
  （使用 "git add <文件>..." 标记解决方案）

	由他们添加： zhouji

未跟踪的文件:
  （使用 "git add <文件>..." 以包含要提交的内容）

	.gitignore

# 博客论坛

## 具体情况 链接：https://ywnz.com/linuxyffq/4335.html

### 安装步骤

1；我们将首先将所有系统软件包更新到最新版本，然后继续安装Jekyll：

$ sudo apt-get update

$ sudo apt-get upgrade

Jekyll需要一个包含库的Ruby开发环境，使用以下命令安装Jekyll和必需的构建工具：

$ sudo apt-get install make build-essential

安装Ruby包和开发工具：

$ sudo apt-get install ruby ruby-dev

2；**从PPA存储库安装Ruby的方法**

我倾向于使用Brightbox PPA存储库，因为它可以灵活地安装他们维护的任何Ruby版本。

1、使用以下命令将PPA存储库添加到Ubuntu 18.04系统中：

sudo apt -y install software-properties-common

sudo apt-add-repository ppa:brightbox/ruby-ng

2、添加repo后，更新系统的包列表：

sudo apt update

3、然后安装你想要的Ruby版本，比如我正在安装Ruby 2.5。

$ sudo apt install ruby2.5

Reading package lists... Done

Building dependency tree    

Reading state information... Done

The following packages were automatically installed and are no longer required:

linux-headers-4.15.0-29 linux-headers-4.15.0-29-generic linux-image-4.15.0-29-generic linux-modules-4.15.0-29-generic

linux-modules-extra-4.15.0-29-generic

Use 'sudo apt autoremove' to remove them.

The following packages will be upgraded:

ruby2.5

1 upgraded, 0 newly installed, 0 to remove and 2 not upgraded.

Need to get 56.6 kB of archives.

After this operation, 2,048 B of additional disk space will be used.

Get:1 http://ppa.launchpad.net/brightbox/ruby-ng/ubuntu bionic/main amd64 ruby2.5 amd64 2.5.3-1bbox1~bionic1 [56.6 kB]

Fetched 56.6 kB in 1s (66.2 kB/s)  

(Reading database ... 141513 files and directories currently installed.)

Preparing to unpack .../ruby2.5_2.5.3-1bbox1~bionic1_amd64.deb ...

Unpacking ruby2.5 (2.5.3-1bbox1~bionic1) over (2.5.1-1ubuntu1.1) ...

Setting up ruby2.5 (2.5.3-1bbox1~bionic1) ...

update-alternatives: using /usr/bin/gem2.5 to provide /usr/bin/gem (gem) in auto mode

update-alternatives: using /usr/bin/ruby2.5 to provide /usr/bin/ruby (ruby) in auto mode

Processing triggers for man-db (2.8.3-2ubuntu0.1) ...

4、在Brightbox维护的Ruby包中有2.4,2.3,2.2,2.1,2.0,1.9.3和1.8.7版本，比如安装Ruby 2.4的示例，使用以下命令：

sudo apt install ruby2.4

5、安装后，检查版本，运行以下命令：

$ ruby --version

结果显示：ruby 2.5.1p57 [x86_64-linux-gnu]

至此，从PPA存储库安装Ruby成功了。

Node.js REPL(交互式解释器)
Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。

Node 自带了交互式解释器，可以执行以下任务：

读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。

执行 - 执行输入的数据结构

打印 - 输出结果

循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。

Node 的交互式解释器可以很好的调试 Javascript 代码。

开始学习 REPL

我们可以输入以下命令来启动 Node 的终端：

$ node

>  

**使用RVM安装Ruby的方法**

可以使用RVM安装Ruby，RVM是一个命令行工具，允许你轻松地安装，管理和使用多个ruby环境。

1、导入RVM GPG密钥：

sudo gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB

2、然后通过运行以下命令在Ubuntu 18.04系统上安装RVM：

curl -L get.rvm.io | sudo bash -s stable

source /etc/profile.d/rvm.sh

3、可以查看版本：

$ rvm --version

rvm 1.29.6 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin

4、通过运行命令安装依赖项：

rvm requirements run

5、安装Ruby命令如下：

\# rvm install 2.5.1

Warning, new version of rvm available '1.29.7', you are using older version '1.29.6'.

You can disable this warning with:   echo rvm_autoupdate_flag=0 >> ~/.rvmrc

You can enable  auto-update  with:   echo rvm_autoupdate_flag=2 >> ~/.rvmrc

Searching for binary rubies, this might take some time.

Found remote file https://rvm_io.global.ssl.fastly.net/binaries/ubuntu/18.04/x86_64/ruby-2.5.1.tar.bz2

Checking requirements for ubuntu.

Requirements installation successful.

ruby-2.5.1 - #configure

ruby-2.5.1 - #download

ruby-2.5.1 - #validate archive

ruby-2.5.1 - #extract

ruby-2.5.1 - #validate binary

ruby-2.5.1 - #setup

ruby-2.5.1 - #gemset created /usr/local/rvm/gems/ruby-2.5.1@global

ruby-2.5.1 - #importing gemset /usr/local/rvm/gemsets/global.gems.............

ruby-2.5.1 - #generating global wrappers.......

ruby-2.5.1 - #gemset created /usr/local/rvm/gems/ruby-2.5.1

ruby-2.5.1 - #importing gemsetfile /usr/local/rvm/gemsets/default.gems evaluated to empty gem list

ruby-2.5.1 - #generating default wrappers.......

6、要列出可用的Ruby，请使用：

rvm list known

至此，使用RVM安装Ruby成功了。

3；我们现在需要指示Ruby的gem包管理器将gem放在登录用户的主目录中，在~/.bashrc或~/.zshrc下添加以下行，具体取决于你的shell：

Node.js REPL(交互式解释器)
Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。

Node 自带了交互式解释器，可以执行以下任务：

读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。

执行 - 执行输入的数据结构

打印 - 输出结果

循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。

Node 的交互式解释器可以很好的调试 Javascript 代码。

开始学习 REPL

我们可以输入以下命令来启动 Node 的终端：

$ node

> export GEM_HOME=$HOME/gems

export PATH=$HOME/gems/bin:$PATH

现在来源.bashrc|.zshrc文件以使更改生效：

$ source ~/.bashrc

$ source ~/.zshrc

完成此操作后，将使用gem安装Jekyll和Bundler，这是一个用于管理Gem依赖项的工具：

$ gem install bundler

Fetching: bundler-1.16.2.gem (100%)

Successfully installed bundler-1.16.2

Parsing documentation for bundler-1.16.2

Installing ri documentation for bundler-1.16.2

Done installing documentation for bundler after 3 seconds

1 gem installed

### 安装Jekyll：

$ gem install jekyll

**二、使用Jekyll创建一个新网站**

现在已经设置了所有必需的东西，让我们继续为Jekyll添加一个站点，为此，我们将使用命令jekyll new site，这将使用默认的Jekyll主题启动所需依赖项的bundle安装，安装成功后，你应该看到如下输出（请把xxx.com换成你的域名，比如ywnz.com）：

$ jekyll new blog.xxx.com

Running bundle install in /home/jmutai/blog.xxx.com... 

Bundler: Don't run Bundler as root. Bundler can ask for sudo if it is needed, and installing your bundle as root will break this application for all non-root users on this

Bundler: machine.

Bundler: The dependency tzinfo-data (>= 0) will be unused by any of the platforms Bundler is installing for. Bundler is installing for ruby but the dependency is only for x86-mingw32, x86-mswin32, x64-mingw32, java. To add those platforms to the bundle, run `bundle lock --add-platform x86-mingw32 x86-mswin32 x64-mingw32 java`.

Bundler: Fetching gem metadata from https://rubygems.org/...........

Bundler: Fetching gem metadata from https://rubygems.org/.

Bundler: Resolving dependencies...

Bundler: Using public_suffix 3.0.2

Bundler: Using addressable 2.5.2

Bundler: Using bundler 1.16.2

Bundler: Using colorator 1.1.0

Bundler: Using concurrent-ruby 1.0.5

Bundler: Using eventmachine 1.2.7

Bundler: Using http_parser.rb 0.6.0

Bundler: Using em-websocket 0.5.1

Bundler: Using ffi 1.9.25

Bundler: Using forwardable-extended 2.6.0

Bundler: Using i18n 0.9.5

Bundler: Using rb-fsevent 0.10.3

Bundler: Using rb-inotify 0.9.10

Bundler: Using sass-listen 4.0.0

Bundler: Using sass 3.5.6

Bundler: Using jekyll-sass-converter 1.5.2

Bundler: Using ruby_dep 1.5.0

Bundler: Using listen 3.1.5

Bundler: Using jekyll-watch 2.0.0

Bundler: Using kramdown 1.17.0

Bundler: Using liquid 4.0.0

Bundler: Using mercenary 0.3.6

Bundler: Using pathutil 0.16.1

Bundler: Using rouge 3.1.1

Bundler: Using safe_yaml 1.0.4

Bundler: Using jekyll 3.8.3

Bundler: Fetching jekyll-feed 0.10.0

Bundler: Installing jekyll-feed 0.10.0

Bundler: Fetching jekyll-seo-tag 2.5.0

Bundler: Installing jekyll-seo-tag 2.5.0

Bundler: Fetching minima 2.5.0

Bundler: Installing minima 2.5.0

Bundler: Bundle complete! 4 Gemfile dependencies, 29 gems now installed.

Bundler: Use `bundle info [gemname]` to see where a bundled gem is installed.

New jekyll site installed in /home/jmutai/blog.xxx.com.

将使用用于创建静态站点的Jekyll源文件创建目录：

$ tree blog.xxx.com/

blog.xxx.com/

├── 404.html

├── Gemfile

├── Gemfile.lock

├── _config.yml

├── _posts

│　　└── 2019-02-22-welcome-to-jekyll.markdown

├── about.md

└── index.md

1 directory, 7 files

请注意，你必须先cd到此目录才能开始使用它：

$ cd blog.xxx.com/

Jekyll的内置轻量级Web服务器将在端口4000上提供内容，如果启用了防火墙服务，则允许访问此端口：

$ sudo ufw allow 4000

Jekyll旨在通过自动检测文件的更改来支持实时开发，并在保存更改时自动重新生成静态站点。

 

**三、启动Jekyll Web Server**

要启动Jekyll内置Web服务，请选择到站点目录并使用jekyll serve命令启动Jekyll Web服务器，然后使用要绑定的主机IP地址：

$ cd ~/blog.xxx.com

$ jekyll serve --host=178.128.164.211

执行jekyll serve命令时，Jekyll将解析配置并将内容文件推送到名为_site的目录中，然后它提供此_site目录中的内容：

$ ls -1 _site/

404.html

about

assets

feed.xml

index.html

jekyll

应该得到如下输出：

Configuration file: /home/jmutai/blog.xxx.com/_config.yml

Source: /home/jmutai/blog.xxx.com

Destination:/home/jmutai/blog.xxx.com/_site

Incremental build: disabled. Enable with --incremental

Generating... 

done in 0.372 seconds.

Auto-regeneration: enabled for '/home/jmutai/blog.xxx.com'

Server address: http://178.128.164.211:4000/

Server running... press ctrl-c to stop.

当保存对帖子或页面的更改时，Jekyll还会在~/blog.xxx.com目录中监视新的更改，它将自动重建静态站点，将所有站点帖子放在_posts目录下。

访问服务器的IP地址和端口4000以查看默认网页：

![在Ubuntu 18.04系统上安装Jekyll的方法](https://ywnz.com/uploads/allimg/19/1-1Z22221444Hc.JPG)

如果你使用的是Nginx或Apache等Web服务器，则需要将_site/中的内容复制到其Web文档根目录。

# C语言

1；人和计算机的交流方式

2；hello 的编写：# include <stdio.h>

int main(){

printf ("hello worid");

return 0;

}



3：比较大小

int max (int a, int b){

if ( a>b){

return  a; 

}else{

return b;

}

}

int main(      )

{

int a1=33;

int a2=22;

int  m=max (a1,a2)

printf ("最大值是：",m);

return 0;

}

4:多平台使用

1：sp  你的林一个文件名

2；ctrl +w   在加上下建 可以控制在那个平台上

可以将比较大小分开 写在两个平台

平台1：

int max (int a, int b){

if ( a>b){

return  a;

m}else{

return b;

}

}



平台2；

int main()

{

int a1=33;

int a2=22;

int  m=max (a1,a2)；

printf ("最大值是：",m);

return 0;

}

## 多数比较

#include<stdio.h>
int max(int a,int b)
{
   if (a>b){
   return a;

}else{
  return b;
}
}
int min(int a ,int b )

{
if(a<b)
{
return a;
}else{
return b;
}
}

int main()
{
int a1=30;
int a2=20;
scanf("%d",&a1);
scanf("%d",&a2);
int m=max(a1,a2);
int a=min(a1,a2);
printf("最大值%d",m);
printf("最小值%d",a);
return 0;
}

#出现的错误 其实并没有错

hello.c:6:10: warning: implicit declaration of function ‘max’; did you mean ‘main’? [-Wimplicit-function-declaration]
    int m=max(a1,a2);
          ^~~

echo $?  查看是否被执行



1；gcc 文件名  -o 后面可以其一个别名

2；./文件名 ：就是执行文件 执行的是别名文件

3；&& 链接符号 可以同时执行两个命令  ./main.c &&  ls 执行完后进行查看 

4；cp 文件名  另一个文件名   ：cp a.txt    b.txt 复制a并其另外一个名子

# 标准的对象 输出 输入流 错误流

#### 三大流

1；stdin 输出流

2；stdout 输入流

3；stderr 错误流

#### 案例 <1>

#include <stdio.h>

int main()

{

printf("hello wold\n");

int a;

scanf("%d",&a);

printf("input values is :%d\n",a)

return 0;

}

#### 案例<2>

#include<stdio.h>
int main()
{
 // ptingf("plesse input the value a:\n"");    
 fprintf(stdout,"plesse input the value a:\n");
 int a;
 //scanf("%d,&a");
 fscanf(stdin,"%d",&a);
 if(a<0){
 fprintf(stderr,"the value must>0");
 return 1;

}
return 0;
}

### 重定向

#### 案例 

###  输出流

#include<stdio.h>

int main()
{
    int i,j;
    printf("input the int value i:\n");
    scanf("%d",&i);
    printf("input the int value j:\n");
    scanf("%d",&j);
    printf("i+j=%d\n",i+j);
    return 0;


}

如果上面案例的文件名为a.txt  给加如一个  1>> 会定义到另外一个文件

如：./a.txt   1>> b.txt    (其中的1可以省咯)





建立一个input文件 

在input.txt 里面写入几个数字

运用下面的操作会有和上面一样的效果

./a.out <input.txt





输错流

#include<stdio.h>

int main()
{
    int i,j;
    printf("input the int value i:\n");
    scanf("%d",&i);
    printf("input the int value j:\n");
    scanf("%d",&j);
    if(0!=j){
      printf("%d/%d=%d\n",i,j,i/j);
    }else{
      fprintf(stderr,"j!=0\n");
      return 1;
    }
    return 0;


}

#### 管道查询

ls / 文件名/  |  grep  ad :: 查看文件里面以ab 开头的文件

ps -a  查看进程

## <1>  平均值的计算

#include<stdio.h>
int main()

{
int s,n;
scanf("%d,%d",&s,&n);
float v=s/n;
printf("v=%f\n",v);
return 0;
}



## <2>  统计数值

#include<stdio.h>
int main()

{
int flag=1;
int i;
int count=0;
int s=0;
while(flag){
scanf("%d",&i);
if(0==i) break;
count++;
s+=i;
}
printf("%d,%d",s,count);
return 0;
}

<1><2>相互结合可以求平均值

用法：文件名1  | 文件名2  （用的是-o后面的文件名）./a.txt | ./b.txt

# 指针型

## C语言指针与内存

#### 一 ：指针

main.c

```
#include <stdio.h>

void change(int *a,int *b)  // *表示指针
{
        int tmp=*a;
        *a=*b;
        *b=tmp;
}
int main()
{
        int a=123;
        int b=456;
        change(&a,&b);   //&表示取地址符号
        printf("num a=%d\nnum b=d%\n",a,b);
}

命令：
cc main.c -o main.out && ./main.out
输出：
//num a=456
//num b=123

```

#### 二：gdb调试工具

main2.c    //未用指针的版本

```
#include <stdio.h>

void change(int a,int b)  // *表示指针
{
        int tmp=a;
        a=b;
        b=tmp;
}
int main()
{
        int a=123;
        int b=456;
        change(a,b);   //&表示取地址符号
        printf("num a=%d\nnum b=%d\n",a,b);
}
```

```
调试过程：
gdb ./main2.out        //调试main2.out
(gdb) list                     //列出源代码
(gdb) start   //Temporary breakpoint 1, main () at main2.c:11   断点位置11行
(gdb) p a      //   $1 = 0         打印a的值
(gdb) n         //12		int b=456;       跳到下一行即12行
(gdb) p a     //$2 = 123     再次打印a
(gdb) p b    //$3 = 0     打印b的值
(gdb) n      //13		change(a,b);    跳到下一行准备执行函数change
(gdb) p a   //$4 = 123      此时的a变量值
(gdb) p b   //$5 = 456     此时的b变量值
(gdb) l      // 查看此行后面内容
(gdb) s  //change (a=123, b=456) at main2.c:5    查看change函数内容，
               //    5		int tmp=a;        此时传递了a,b变量的值
(gdb) n  //  6		a=b;       执行下一行
(gdb) p a  //$6 = 123       此时的a变量值
(gdb) p b  //$7 = 456        此时的b变量值
(gdb) bt              // 查看函数堆栈（各个函数堆起来的）
     //#0  change (a=123, b=456) at main2.c:6   编号0的是change函数
     //#1  0x000055555555468e in main () at main2.c:13  编号1是main函数在13行调用
(gdb) p a  //$8 = 123    此时a值为函数change里面的a值
(gdb) f 1     //  切换到函数堆栈编号为1的函数
         //#1  0x000055555555468e in main () at main2.c:13
         //13		change(a,b);
(gdb) f 0    //   切换到函数堆栈编号为0的函数
        //#0  change (a=456, b=123) at main2.c:8
        //8	}
(gdb) n    //执行到最后一行时，结果如下，change函数并为成功达到我们预期效果，
//num a=123
//num b=456     a 和 b的值并为被交换
//15	}
(gdb) q //退出调试程序
原因分析：a和b只是局部变量，并没有指向，所以change函数传参时不会改变a和b的值      来传递
```

```
调试main.c的输出文档main.out：
gdb ./main.out       
(gdb) l                  
(gdb) start
(gdb) n
		//13		change(&a,&b);   
(gdb) s             //查看change函数内容
       //change (a=0x7fffffffdf80, b=0x7fffffffdf84) at main.c:5  
       //此时a和b都表示一个堆栈地址，传递时只传递地址
       //5		int tmp=*a;     下一行内容
(gdb) n           //运行到最后时，a和b的值发生交换
		//num a=456
		//num b=123
		//15	}
原因分析：加上*符号后，在*a和*b传递时，只传递栈地址，而不会传递具体数值，发生改变的只是a/b变量的地址交换，从而使a/b的值发生交换
```

#### 三  数据表示方法

##### 	1 计算机中二进制：

​		高电位：1   			 低电位：0

32位操作系统只能使用4G内存：

32位表示有32根地址总线，总共可以存储2^32个字节

即 2^10 * 2^10 * 2^10* 2^2字节

​	=1024 * 1024 * 1024*4字节

​	=1024*1024 * 4k字节

​	=1024*4 M字节

​	=4G字节

#####     2  内存分布  64位操作系统为例

48-64位为     系统内核

高位段			栈内存   存放第一个运行的程序  如：main函数等等

中位段			自由分配内存

低位段			堆内存 

低位段			数据段  声明的一些全局变量或者常量  

 										const int i；//常量    int global；//全局变量								

低位段			代码段 代码编译后的二进制数据加载到内存中

内存的操作：一般是操作系统来统筹规划

##### 3 变量和指针的本质

​	当前程序运行的状态被记录在栈内存中

​	变量的本质：变量名只是一个标识符，一个代号，变量的本质是内存空间；

​    指针的本质：指针保存的是变量的内存地址；指针的本质就是地址；

##### 4 操作系统对内存的管理

​		堆栈段：

  　　1. 为函数内部的局部变量提供存储空间。

        　　2. 进行函数调用时，存储“过程活动记录”。

​         3  用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入		堆栈

​        4 GCC会对内存变量分配进行优化：同一种变量类型会放到一块

​	64位计算机：指针占8位字节，变量占4位字节

```
一般把源代码编译完成为目标文件的代码就存在代码段；调用的函数指针的顺序就存放在栈内存，可以理解为栈的先进后出就是函数的调用的顺序；打印函数内部变量在代码段的存储位置：首先要用bt 显示你的栈内存顺序，再用f + 编号，进去你想打印变量所在的函数里面，再用p+ &变量名字，即可打印
```



##### 5 函数栈及数据段内存		

​		栈的特点：先进后出

​		数据段/代码段越往后声明的地址越大

​		栈越往后声明的地址越小，栈顶向下分配

​		静态变量在每个函数间都不互相影响，是独立变量。一个函数内的静态变量不管		函数运行多少次都在同一位置改动

##### 6 函数指针与指针指向的数据访问

​	函数指针格式： 返回值类型 (*变量名)(形参列表);

​	int quadraate(int a);是一个函数  

​	int （*pquadrate)(int a)=&quadrate;则是指向这个函数的指针  

​	int s=(*pquadrate)(a)可以调用函数

 	一个指针变量* q    不加*号：P q  取出自己地址中存储的值（一个地址），

​	加*号：P *q  取出指向地址中存储的值。

​	在内存里面会在编译时归纳排列，栈内存记录函数活动，代码段记录指令，数据记录申明

```
&*p：取变量a的地址（先进行*运算，*p相当于变量a，再进行&运算，&*p就相当于取变量a的地址）
*&p：取变量a所在地址的值（先进行&运算，&a相当于取变量a的地址，在执行*运算，*&p相当于取变量a所在地址的值）
```

#### 四   字符串与数组                    

##### 	1  数组申明的内存排列

​			在程序中，使用一个未声明变量的地址，改地址里面的值是随机的。C语言没有对地址的合法性进行检查

​			程序中声明的同一种变量在内存中连续排列

​			数组长度为常量，每一次定义的数组空间是固定的，声明的地址空间连续排放

​			x/3d 0x7ffffffffffffde14  从0x7ffffffffffffde14开始按10进制输出3个地址的内容，间隔4字节

```
gdb命令：x（打印内存值）/3（输出3个值）d（十进制显示） 0xffffff（开始地址）
```

​		 指针变量其实代表的是地址，加*表示取这个地址的值

​		p=&a后，获取了a的地址，p++时就是对一个十六进制的地址进行自加运算。

​		指针是动态数组； 		

```
#include <stdio.h>
int main()
{
        int a=3;
        int b=2;
        int array[2];
        array[0]=1;
        array[1]=10;
        array[2]=100;
        int *p=&a;
        int i;
        for(i=0;i<6;i++){
                printf("*p=%d\n",*p);
                p++;
        }
        printf("---------------------\n");
        p=&a;
        for(i=0;i<6;i++){
                printf("p[%d]=%d\n",i,p[i]);
        }
}
//*** stack smashing detected ***: <unknown> terminated
//已放弃 (核心已转储)
//mx@mx-ThinkPad-T420:~/c$ cc m.c -fno-stack-protector    解决办法
*p=3
*p=1
*p=2
*p=24583168
*p=32765
*p=-924518928
---------------------
p[0]=3
p[1]=1
p[2]=2
p[3]=24583156
p[4]=32765
p[5]=-924518928

0x7fffffffdf64:	3	0	2	-8344
0x7fffffffdf74:	32767	1431651824	1	10
0x7fffffffdf84:	100	-1087199744

```

##### 2  指针运算

```
指针数组和数组指针的区别：

数组指针（也称行指针）
定义 int (*p)[n];
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

在32 位系统下任何类型的指针永远是占4 个字节。即数组指针永远占4个字节。

数组与指针的不同在于数组是地址常量，而指针是地址变量
```

```
1.出现的*p=&a和p=&a

请注意第一次时 int *p 是指针声明 =&a 这是赋值。第二次的 p=&a 也是赋值 但是p前面没有加* 因为已经声明过了 除了声明地方之外的*p 意义为：取p这个指针变量所指向的地址中的值

2.p++：指针偏移，运行效率高

3.p+3与*p+3区别：前者是把现指针向下移动三格，后者是对指针所指地址的变量进行操作（数学运算加3）
```

##### 3  字符数组与指针字符串

```
#include <stdio.h>
int main()
{
        char str[]="hello";
        char *str2="world";
        char str3[10];
        printf("input the value \n");
        scanf("%s",str2);
        printf("str is %s\n",str);
        printf("str2 is %s\n",str2);
        printf("str3 is %s\n",str3);
}

```

​		字符串是以'/000'结束的 堆、栈内存中的内容是以更改的，代码段内存中的内容不允许修改。 实例： char *str = "apple"; scanf("%s",str); 这是错误的，因为str指向的是代码段内存中的内容，该内容不能进行修改

##### 4 深入理解

​		指针：int *p; *p  表示所指向的内存空间的值; 

​					p   是所指向内存空间的内存首地址; 

​					&p 是指p指针变量在内存中的地址;

字符串在遇到\0时就会停止不会执行后面的 

数组赋值时不要溢出 会覆盖其他地址甚至其他数据 数组和数组地址不是连续的 会空几个地址 

数组其实就是连续的地址 比如可以用for循环挨个打印元素

 在char数组里 \0也是一个元素 在字符串中是隐藏的元素

 在单个字符元素时要以‘\0’结尾 

数组和指针的差别 数组的开始地址不能改变 但可以改变他指向的地址的内容 而指针可以改变;

#### 案例 

#include<stdio.h>
void change(int *a,int *b)
{
int tmp=*a;
*a=*b;
*b=tmp;
}

int main()
{
int a=5;
int b=3;
change(&a,&b);
printf("num a=%d\n num b=%d\n",a,b);
}

# gdb的使用

1；bt 查看堆区和战区

2；f 切换函数

3；n 下一行

4；s 查看

5；l 查看

6;    q退出

7；gcc -g 文件名 编译文件 调试

8；gdb 文件名 运行文件-0后面的文件名
9;   start 运行

10；p  &a 查看a的地址（实际地址）

#####  指针就是保存内存的地址

# 堆区特点

1；先进先出

例如 int  a  ： a没有具体的值会被放在堆去

有具体的值被放在栈区 堆区和栈区中间有一定的自由空间

#  栈区特点

1；先进后出



# 异常代码 

#include<stdio.h>
int main()

{
 int a=3;
 int b=2;
 int array[3];
 array[0]=1;
 array[1]=10;
 array[2]=100;
 int *p=&a;
 int i;
 for(i=0;i<6;i++){
     printf("*p-%d\n",*p);
     p++;
 }
printf("............................\n");
p=&a;
for(i=0;i<6;i++){
  printf("p[%d]=%d\n",i,p[i]);

}
}

#  SUblime的下载与安装

##  1第一支种

安装GPG密钥：

```
wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -
```

确保将apt设置为可与https来源一起使用：

```
sudo apt-get install apt-transport-https
```

选择要使用的频道：

- 稳定

  `echo "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.list `

- 开发人员

  `echo "deb https://download.sublimetext.com/ apt/dev/" | sudo tee /etc/apt/sources.list.d/sublime-text.list `

更新apt源并安装Sublime Text

```
sudo apt-get update
sudo apt-get install sublime-text
```



## 2第二种

安装GPG密钥：

```
curl -O https://download.sublimetext.com/sublimehq-pub.gpg && sudo pacman-key --add sublimehq-pub.gpg && sudo pacman-key --lsign-key 8A8F901A && rm sublimehq-pub.gpg
```

选择要使用的频道：

- 稳定

  `echo -e "\n[sublime-text]\nServer = https://download.sublimetext.com/arch/stable/x86_64" | sudo tee -a /etc/pacman.conf `

- 开发人员

  `echo -e "\n[sublime-text]\nServer = https://download.sublimetext.com/arch/dev/x86_64" | sudo tee -a /etc/pacman.conf `

更新pacman并安装Sublime Text

```
sudo pacman -Syu sublime-text
```

# 截取与拼接

        var i=phone.indexOf("@");
        var val=phone.substring(0,i);
# 正则表达式

正则表达式是由一个字符序列形成的搜索模式。

当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。

正则表达式可以是一个简单的字符，或一个更复杂的模式。

正则表达式可用于所有文本搜索和文本替换的操作。

格式：： var 变量=//g;

# 获取各种时间日期

### 格式

//获取年份  

 var y = date.getFullYear(); 

 //获取月份  返回0-11    

 var M=date.getMonth()+1; 

 // 获取日  

 var d = date.getDate();
 //时
 var h = date.getHours();
 //分  

 var m = date.getMinutes() 
 //秒 

 var s = date.getMilliseconds() ;

# alert

用法：alert("需要输出的内");

# switch 的用法

prompt:输入的意思

var a=prompt("提示输入的什么什么");

switch  (){

case 需要返回的：内容；break;

}

switch(n) {  

  case 1:        执行代码块 1        break;   

 case 2:        执行代码块 2        break;   

 default:        与 case 1 和 case 2 不同时执行的代码

}

# 案例

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
  <input placeholder="请输入">
  <button onclick="x1()">确认</button> 


  <script type="text/javascript">  

  //创建对象 
  var date = new Date();  
  //获取年份  
  var y = date.getFullYear(); 
  //获取月份  返回0-11     
  var M=date.getMonth()+1; 
  // 获取日   
  var d = date.getDate();
  //时
  var h = date.getHours();
  //分  
  var m = date.getMinutes() 
  //秒 

  var s = date.getMilliseconds() ;

  alert(y+"-"+M+"-"+d+"/"+h+":"+m+":"+s); 

  function x1(){
    var a = document.getElementsByTagName("input")[0].value;
    switch(a){
    case 'YY' : alert(y);break;
    case 'MM' : alert(y+"-"+M);break;
    case 'DD' : alert(y+"-"+M+"-"+d);break;
    case 'hh' : alert(y+"-"+M+"-"+d+"/"+h);break;
    case 'mm' : alert(y+"-"+M+"-"+d+"/"+h+":"+m);break;
    case 'ss' : alert(y+"-"+M+"-"+d+"/"+h+":"+m+":"+s);break;
    case 'YYYY' : alert(y);break;
    case 'YYYY-MM' : alert(y+"-"+M);break;
    case 'YYYY-MM-DD' : alert(y+"-"+M+"-"+d);break;
    case 'YYYY-MM-DD  hh' : alert(y+"-"+M+"-"+d+"/"+h);break;
    case 'YYYY-MM-DD  hh：mm' : alert(y+"-"+M+"-"+d+"/"+h+":"+m);break;
    case 'YYYY-MM-DD  hh：mm：ss' : alert(y+"-"+M+"-"+d+"/"+h+":"+m+":"+s);break;
    

    }

  }

  </script>
</body>
</html



# do/while用法

do/while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。

do
{
  *需要执行的代码
*}
while (*条件*);

# JavaScript 语句

1：下面的 JavaScript 语句向 id="demo" 的 HTML 元素输出文本 "你好 Dolly" ：

## 实例

document.getElementById("demo").innerHTML = "你好 Dolly";

2：JavaScript 代码块

本例向网页输出一个标题和两个段落：

## 实例

function myFunction() {    document.getElementById("demo").innerHTML="你好Dolly";    document.getElementById("myDIV").innerHTML="你最近怎么样?"; }

# JavaScript 语句标识符

| break        | 用于跳出循环。                                               |
| ------------ | ------------------------------------------------------------ |
| catch        | 语句块，在 try 语句块执行出错时执行 catch 语句块。           |
| continue     | 跳过循环中的一个迭代。                                       |
| do ... while | 执行一个语句块，在条件语句为 true 时继续执行该语句块。       |
| for          | 在条件语句为 true 时，可以将代码块执行指定的次数。           |
| for ... in   | 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 |
| function     | 定义一个函数                                                 |
| if ... else  | 用于基于不同的条件来执行不同的动作。                         |
| return       | 退出函数                                                     |
| switch       | 用于基于不同的条件来执行不同的动作。                         |
| throw        | 抛出（生成）错误 。                                          |
| try          | 实现错误处理，与 catch 一同使用。                            |
| var          | 声明一个变量。                                               |
| while        | 当条件语句为 true 时，执行语句块。                           |

# JavaScript for 循环

案例：for (var i=0;i<cars.length;i++) {     document.write(cars[i] + "<br>"); }

不同的循环体：

## 不同类型的循环

JavaScript 支持不同类型的循环：

- **for** - 循环代码块一定的次数
- **for/in** - 循环遍历对象的属性
- **while** - 当指定的条件为 true 时循环指定的代码块
- **do/while** - 同样当指定的条件为 true 时循环指定的代码块

# For 循环

for 循环是您在希望创建循环时常会用到的工具。

下面是 for 循环的语法：

for (*语句 1*; *语句 2*; *语句 3*)
{
  *被执行的代码块*
}

# For/In 循环

JavaScript for/in 语句循环遍历对象的属性：

## 实例

var person={fname:"John",lname:"Doe",age:25};  

 for (x in person)  // x 为属性名

 {    

txt=txt + person[x];

 }

# JavaScript 输出

JavaScript 没有任何打印或者输出的函数。

## JavaScript 显示数据

JavaScript 可以通过不同的方式来输出数据：

- 使用 **window.alert()** 弹出警告框。
- 使用 **document.write()** 方法将内容写到 HTML 文档中。
- 使用 **innerHTML** 写入到 HTML 元素。
- 使用 **console.log()** 写入到浏览器的控制台。

------

## 使用 window.alert()

你可以弹出警告框来显示数据：

### 实例

<!DOCTYPE html>
<html>
<body>

<h1>我的第一个页面</h1>
<p>我的第一个段落。</p>
<script>
window.alert(5 + 6);
</script>

</body>
</html>

------

## 操作 HTML 元素

如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(*id*) 方法。



请使用 "id" 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：

## 实例

<!DOCTYPE html>
<html>
<body>

<h1>我的第一个 Web 页面</h1>
<p id="demo">我的第一个段落</p>
<script>
document.getElementById("demo").innerHTML = "段落已修改。";
</script>

</body>
</html>

以上 JavaScript 语句（在 <script> 标签中）可以在 web 浏览器中执行：

**document.getElementById("demo")** 是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。

**innerHTML = "段落已修改。"** 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码

------

## 写到 HTML 文档

出于测试目的，您可以将JavaScript直接写在HTML 文档中：

## 实例

<!DOCTYPE html>
<html>
<body>

<h1>我的第一个 Web 页面</h1>
<p>我的第一个段落。</p>
<script>
document.write(Date());
</script>

</body>
</html>

## 实例

<!DOCTYPE html>
<html>
<body>

<h1>我的第一个 Web 页面</h1>
<p>我的第一个段落。</p>
<button onclick="myFunction()">点我</button>

<script>
function myFunction() {
  document.write(Date());
}
</script>

</body>
</html>

------

## 写到控制台

如果您的浏览器支持调试，你可以使用 **console.log()** 方法在浏览器中显示 JavaScript 值。

浏览器中使用 F12 来启用调试模式， 在调试窗口中点击 "Console" 菜单。

## 实例

<!DOCTYPE html>
<html>
<body>

<h1>我的第一个 Web 页面</h1>
<script>
a = 5;
b = 6;
c = a + b;
console.log(c);
</script>

</body>
</html>

# Node.js 教程

建立体格js 文件 进入这个文件随便写如点东西  保存退出  然后运行

步骤：

vim www.js

在里面写入东西:console.log("hello world"); 保存退出： 

使用node 文件名.js 运行

# Node.js 安装配置

1；下载地址

Node.js 安装包及源码下载地址为：https://nodejs.org/en/download/。

![nodejs_download](https://www.runoob.com/wp-content/uploads/2014/03/download-page.jpg)

## Windows 上安装 Node.js

你可以采用以下两种方式来安装。

### 1、Windows 安装包(.msi)

32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi

64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi

本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤：

步骤 1 : 双击下载后的安装包 **v0.10.26**，如下所示：

![install-node-msi-version-on-windows-step1](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step1.png)

步骤 2 : 点击以上的Run(运行)，将出现如下界面：

![install-node-msi-version-on-windows-step2](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step2.png)

步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 :

![install-node-msi-version-on-windows-step3](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step3.png)

步骤 4 : Node.js默认安装目录为 "C:\Program Files\nodejs\" , 你可以修改目录，并点击 next（下一步）：

![install-node-msi-version-on-windows-step4](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step4.png)

步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步）

![install-node-msi-version-on-windows-step5](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step5.png)

步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）：

![install-node-msi-version-on-windows-step6](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step6.png)

安装过程：

![install-node-msi-version-on-windows-step7](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step7.png)

点击 Finish（完成）按钮退出安装向导。

![install-node-msi-version-on-windows-step8](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step8.png)

检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入"cmd" => 输入命令"path"，输出如下结果：

```
PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;
C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;
c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;
C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;
C:\Users\rg\AppData\Roaming\npm
```

我们可以看到环境变量中已经包含了C:\Program Files\nodejs\

检查Node.js版本

![node-version-test](https://www.runoob.com/wp-content/uploads/2014/03/node-version-test.png)

### 2、Windows 二进制文件 (.exe)安装

32 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/node.exe

64 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/x64/node.exe

**安装步骤**

步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 :

![install-node-exe-on-windows-step1](https://www.runoob.com/wp-content/uploads/2014/03/install-node-exe-on-windows-step1.png)

点击 Run（运行）按钮将出现命令行窗口：

![install-node-exe-on-windows-step21](https://www.runoob.com/wp-content/uploads/2014/03/install-node-exe-on-windows-step21.png)

### 版本测试

进入 node.exe 所在的目录，如下所示：

![node-version](https://www.runoob.com/wp-content/uploads/2014/03/node-version.png)

如果你获得以上输出结果，说明你已经成功安装了Node.js。

------

## Linux 上安装 Node.js

### 直接使用已编译好的包

Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用：

```
# wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz    // 下载
# tar xf  node-v10.9.0-linux-x64.tar.xz       // 解压
# cd node-v10.9.0-linux-x64/                  // 进入解压目录
# ./bin/node -v                               // 执行node命令 查看版本
v10.9.0
```

解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：

```
ln -s /usr/software/nodejs/bin/npm   /usr/local/bin/ 
ln -s /usr/software/nodejs/bin/node   /usr/local/bin/
```

### Ubuntu 源码安装 Node.js

以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.js 。 其他的 Linux 系统，如 Centos 等类似如下安装步骤。

在 Github 上获取 Node.js 源码：



```
$ sudo git clone https://github.com/nodejs/node.git
Cloning into 'node'...
```

修改目录权限：

```
$ sudo chmod -R 755 node
```

使用 **./configure** 创建编译文件，并按照：

```
$ cd node
$ sudo ./configure
$ sudo make
$ sudo make install
```

查看 node 版本：

```
$ node --version
v0.10.25
```

### Ubuntu apt-get命令安装

命令格式如下：

```
sudo apt-get install nodejs
sudo apt-get install npm
```

### CentOS 下源码安装 Node.js

1、下载源码，你需要在https://nodejs.org/en/download/下载最新的Nodejs版本，本文以v0.10.24为例:

```
cd /usr/local/src/
wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz
```

2、解压源码

```
tar zxvf node-v0.10.24.tar.gz
```

3、 编译安装

```
cd node-v0.10.24
./configure --prefix=/usr/local/node/0.10.24
make
make install
```

4、 配置NODE_HOME，进入profile编辑环境变量

```
vim /etc/profile
```

设置 nodejs 环境变量，在 ***export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL*** 一行的上面添加如下内容:

```
#set for nodejs
export NODE_HOME=/usr/local/node/0.10.24
export PATH=$NODE_HOME/bin:$PATH
```

:wq保存并退出，编译/etc/profile 使配置生效

```
source /etc/profile
```

验证是否安装配置成功

```
node -v
```

输出 v0.10.24 表示配置成功

npm模块安装路径

```
/usr/local/node/0.10.24/lib/node_modules/
```

**注：**Nodejs 官网提供了编译好的 Linux 二进制包，你也可以下载下来直接应用。

------

## Mac OS 上安装

你可以通过以下两种方式在 Mac OS 上来安装 node：

- 

- 1、在

  官方下载网站

  下载 pkg 安装包，直接点击安装即可。

  

- 2、使用 brew 命令来安装：

  ```
  brew install node
  ```

## 创建 Node.js 应用

### 步骤一、引入 required 模块

我们使用 **require** 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:

```
var http = require("http");
```

### 步骤二、创建服务器

接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。

实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：

```
var http = require('http');

http.createServer(function (request, response) {

    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});

    // 发送响应数据 "Hello World"
    response.end('Hello World\n');
}).listen(8888);

// 终端打印如下信息
console.log('Server running at http://127.0.0.1:8888/');
```

以上代码我们完成了一个可以工作的 HTTP 服务器。

使用 **node** 命令执行以上的代码：

```
node server.js
Server running at http://127.0.0.1:8888/
```

![img](https://www.runoob.com/wp-content/uploads/2014/03/cmdrun.jpg)

接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 "Hello World"的网页。

![img](https://www.runoob.com/wp-content/uploads/2014/03/nodejs-helloworld.jpg)

**分析Node.js 的 HTTP 服务器：**

- 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。
- 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。

# npm安装中出现的问题处理方式：

先卸载nodejs，然后安装稳定最新版

#### 有些是需要增加权限的 可以加在前面 加sudo进行处理

```
# apt-get remove nodejs   //删除nodejs  
# curl -sL https://deb.nodesource.com/setup_8.x | sudo bash - //nodejs源  
# apt-get update //更新包  
# apt-get install nodejs //安装nodejs  
# npm install npm -g //更新npm  
```

## REPL 命令

- **ctrl + c** - 退出当前终端。
- **ctrl + c 按下两次** - 退出 Node REPL。
- **ctrl + d** - 退出 Node REPL.
- **向上/向下 键** - 查看输入的历史命令
- **tab 键** - 列出当前命令
- **.help** - 列出使用命令
- **.break** - 退出多行表达式
- **.clear** - 退出多行表达式
- **.save \*filename\*** - 保存当前的 Node REPL 会话到指定文件
- **.load \*filename\*** - 载入当前 Node REPL 会话的文件内容。

## NPM 常用命令

除了可以在[npmjs.org/doc/](https://npmjs.org/doc/)查看官方文档外，这里再介绍一些NPM常用命令。

NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。

- NPM提供了很多命令，例如`install`和`publish`，使用`npm help`可查看所有命令。
- 使用`npm help `可查看某条命令的详细帮助，例如`npm help install`。
- 在`package.json`所在目录下使用`npm install . -g`可先在本地安装当前命令行程序，可用于发布前的本地测试。
- 使用`npm update `可以把当前目录下`node_modules`子目录里边的对应模块更新至最新版本。
- 使用`npm update  -g`可以把全局安装的对应命令行程序更新至最新版。
- 使用`npm cache clear`可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。
- 使用`npm unpublish @`可以撤销发布自己发布过的某个版本代码。

------

## 使用淘宝 NPM 镜像

大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。

淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。

你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:

```
$ npm install -g cnpm --registry=https://registry.npm.taobao.org
```

这样就可以使用 cnpm 命令来安装模块了：

```
$ cnpm install [name]
```

## 使用 npm 命令安装模块

npm 安装 Node.js 模块语法格式如下：

```
$ npm install <Module Name>
```

以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 **express**:

```
$ npm install express
```

安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 **require('express')** 的方式就好，无需指定第三方包路径。

```
var express = require('express');
```

------

## 全局安装与本地安装

npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如

```
npm install express          # 本地安装
npm install express -g   # 全局安装
```

如果出现以下错误：

```
npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 
```

解决办法为：

```
$ npm config set proxy null
```

###  Package.json 属性说明

- **name** - 包名。
- **version** - 包的版本号。
- **description** - 包的描述。
- **homepage** - 包的官网 url 。
- **author** - 包的作者姓名。
- **contributors** - 包的其他贡献者姓名。
- **dependencies** - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。
- **repository** - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
- **main** - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。
- **keywords** - 关键字

------

## 卸载模块

我们可以使用以下命令来卸载 Node.js 模块。

```
$ npm uninstall express
```



卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：

```
$ npm ls
```

------

## 更新模块

我们可以使用以下命令更新模块：

```
$ npm update express
```

------

## 搜索模块

使用以下来搜索模块：

```
$ npm search express
```

# Node.js REPL(交互式解释器)

Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。

Node 自带了交互式解释器，可以执行以下任务：

- **读取** - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。
- **执行** - 执行输入的数据结构
- **打印** - 输出结果
- **循环** - 循环操作以上步骤直到用户两次按下 **ctrl-c** 按钮退出。

Node 的交互式解释器可以很好的调试 Javascript 代码。

开始学习 REPL

我们可以输入以下命令来启动 Node 的终端：

```
$ node
> 
```

# Node.js 回调函数

Node.js 异步编程的直接体现就是回调。

异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。

回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。

例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。

回调函数一般作为函数的最后一个参数出现：

```
function foo1(name, age, callback) { }
function foo2(value, callback1, callback2) { }
```

------

## 阻塞代码实例

创建一个文件 input.txt ，内容如下：

```
菜鸟教程官网地址：www.runoob.com
```

创建 main.js 文件, 代码如下：

```
var fs = require("fs");

var data = fs.readFileSync('input.txt');

console.log(data.toString());
console.log("程序执行结束!");
```

以上代码执行结果如下：

```
$ node main.js
菜鸟教程官网地址：www.runoob.com

程序执行结束!
```

------

## 非阻塞代码实例

创建一个文件 input.txt ，内容如下：

```
菜鸟教程官网地址：www.runoob.com
```

创建 main.js 文件, 代码如下：

```
var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log("程序执行结束!");
```

以上代码执行结果如下：

```
$ node main.js
程序执行结束!
菜鸟教程官网地址：www.runoob.com
```

# Node.js 事件循环

Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。

Node.js 几乎每一个 API 都是支持回调函数的。

Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。

Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.

------

## 事件驱动程序

Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。

当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。

这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）

在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。



![img](https://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg)

Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：

```
// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
```

### 实例

// 引入 events 模块 

var events = require('events'); 

// 创建 eventEmitter 对象 

var eventEmitter = new events.EventEmitter(); 

 // 创建事件处理程序 

var connectHandler = function connected() {   console.log('连接成功。');     

// 触发 data_received 事件   

 eventEmitter.emit('data_received'); }  

// 绑定 connection 事件处理程序 

eventEmitter.on('connection', connectHandler);  

// 使用匿名函数绑定 data_received 事件 eventEmitter.on('data_received', function(){   console.log('数据接收成功。'); });  

// 触发 connection 事件  

eventEmitter.emit('connection');  console.log("程序执行完毕。");

接下来让我们执行以上代码：

```
$ node main.js
连接成功。
数据接收成功。
程序执行完毕。
```

## Node 应用程序是如何工作的？

在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。

接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：

```
菜鸟教程官网地址：www.runoob.com
```

创建 main.js 文件，代码如下：

```
var fs = require("fs");

fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log("程序执行完毕");
```

以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。

如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。

执行以上代码，执行结果如下：

```
程序执行完毕
菜鸟教程官网地址：www.runoob.com
```

接下来我们删除 input.txt 文件，执行结果如下所示：

```
程序执行完毕
Error: ENOENT, open 'input.txt'
```

因为文件 input.txt 不存在，所以输出了错误信息。

# Node.js EventEmitter

Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。

Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。

------

## EventEmitter 类

1;   引入events 

var evevts=require ("events");

2;   var eventEmitter=new events.EventEmitter();

EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。

下面我们用一个简单的例子说明 EventEmitter 的用法：

```
//event.js 文件
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 
```

      for(var i=0;i<5;i++){
            for(var j=5;j>i;j--){
               console.log(" ");
            }
            for(var k=0;k<2*i+1;k++){
               console.log("0");
            }
    
                 console.log(" ");
         }


# Node.js 函数

在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。

Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：

```
function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");
```

以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！

这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。

当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。

------

## 匿名函数

我们可以把一个函数作为变量传递。但是我们不一定要绕这个"先定义，再传递"的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：

```
function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
```

我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。

用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。

# 空心的类型

1：三角型

```
function kxsjx(b,c,d){
var a="";
      for(i=0;i<6;i++){
        for(j=6;j>i;j--){
           a+=' ';
        }

    for(k=1;k<=2*i+1;k++){
            if(k==1||k==2*i+1){
            a+="*";
            }else if(i==5){
            a+=b;

            }else{

            a+=c;
            }
    }
         a+=d;
}
 console.log(a);
}
kxsjx("*"," ","\n");

```

2：在方形

```
function kxzfx(b,c,d,e,f,g){
var a=b;
      for(x=0;x<5;x++){
        for(j=0;j<5;j++){
        if(x==0||x==4){
            a+=c;
        }else if(j==0||j==4){
        a+=d;
        }else{

        a+=e;
        }
                a+=f;
        }
              a+=g;
        }
 console.log(a);
}
kxzfx("","*","*"," "," ","\n");
~                                                                               
~                                                                               
~   
```

3：梯形

```
var a="";
      for(i=3;i<10;i++){
        for(j=10;j>i;j--){
           a+=' ';
        }

    for(k=3;k<=2*i+1;k++){
            if(k==3||k==2*i+1||i==3||i==9){
            a+=b;
            }else if(i==10){
            a+=b;

            }else{

            a+=c;
            }
    }
         a+=d;

}
 console.log(a);
}
kxtxd("*"," ","\n");

```

4：菱形

```
function kxlx(b,c){
var a=b;
      for(i=0;i<c;i++){
        for(j=c;j>i;j--){
           a+=' ';
        }
         for( k=0;k<(2*i+1);k++){
	if(k==1||k==(2*i-1)){
	 a+="*";

	}else{
	a+=' ';

	
	}	 
	
	  }
	      a+="\n";
      }

for(i=c;i>0;i--){
        for(j=c;j>i;j--){
           a+=' ';
        }
         for( k=0;k<=(2*i-1);k++){
	 if(k==1||k==(2*i-1)){
	     a+='*';
       }else{
       a+=' ';
       
       }
	 }
         a+="\n";
}
 console.log(a);
}
kxlx(" ","6");

```

# 实心的

1：正房

```
function zfx(b,c,d,e,f,g){

var a=b;
      for(i=0;i<c;i++){
        for(j=0;j<d;j++){
	a+=e;	
	a+=f;	
        }
       a+=g;
}

 console.log(a);
}
zfx("","6","6"," ","*","\n");
```

2：三角

```
function sjx(b,c,d){
var a=b;
      for(i=0;i<5;i++){
        for(j=c;j>i;j--){
           a+=' ';
        }
         for( k=0;k<2*i+1;k++){
                 a+=d;

       }
         a+="\n";
}
 console.log(a);
}
sjx("","5","*");
```

3：菱形

```
function lx(b,c,d){
var a=b;
      for(i=c;i<6;i++){
        for(j=d;j>i;j--){
           a+=' ';
        }
         for( k=0;k<2*i+1;k++){
	 a+="*";
	 }	 
	 a+="\n";
      }



for(i=5;i>0;i--){
        for(j=6;j>=i;j--){
           a+=' ';
        }
         for( k=0;k<2*i-1;k++){
         a+="*";
         } 
         a+="\n";
      }
 console.log(a);
}
lx("","0","6");


```

4:梯形

```
function txd(b,c,d){
var a="";
      for(i=1;i<b;i++){
        for(j=b;j>i;j--){
           a+=' ';
        }
         for( k=0;k<2*i+1;k++){


                 a+=c;

       }
         a+=d;
}
 console.log(a);
}
txd("5","*","\n");
```



https://blog.csdn.net/amensia_ZhangSan/article/details/90741502

# http协议

res end("hello world");  只发送请求，并断开链接

res write     只发送请求，不断开链接

# HTTP协议原理

```
HTTP协议原理
```

 

# 用户访问网站的基本流程：

> 1，登录浏览器输入网址 
> 2，网址通过DNS解析出具体IP地址 
> 3，TCP三次握手 
> 4，浏览器向服务商的Web服务器发起一个请求（遵循http协议） 
> 5，Web服务器响应用户请求，处理请求，返回响应包 
> 6，浏览器通过http协议接收到响应包 
> 7，浏览器处理响应包显示在浏览器上 
> 8，TCP四次挥手

 

# DNS的域名解析流程：

> 1，先找本地PC的本地缓存 
> 2，本地hosts映射文件里面是否做了DNS的映射 
> 3，查找本机的DNS，叫LDNS 
> 4，DNS接收以后，找自己的缓存 
> 5，LDNS的hosts有没有 
> 6，LDNS找本地记录本 
> 如果前六步能查到IP地址，叫做DNS的递归查询 
> 7，还没有找到就发起求助，叫做迭代查询

 

# DNS的迭代查询流程

> 世界上有13台大型的域名解析服务器,叫做点服务器,只要含有点就跟它有关系 
> DNS向离它最近的一台点服务器求助 
> 点服务器就把.com的地址发送了LDNS 
> LDNS求组.com 
> .com只给了LDNS baidu.com的位置 
> LDNS向.baidu.com求组 
> baidu.com知道 就给ldns www.baidu.com 
> 然后LDNS把具体的地址存到自己的缓存里,然后发给PC 
> PC在把这个存到自己的缓存里

 

# HTTP协议简介

> HTTP又叫超文本传输协议
>
> HTTP是加密的协议
>
> HTTP默认监听端口80
>
> HTTPS默认端口443

![image_1cqn64ijjhob1a1g1fko1qg214tp2h.png-36.2kB](http://static.zybuluo.com/linyaonie/8l6brvgaf3a6dedqpxsuovq7/image_1cqn64ijjhob1a1g1fko1qg214tp2h.png)

 

# HTTP请求方法

> GET 读 客户端请求指定资源信息，服务器返回指定资源，读的速度快 明文的不加密
>
> POST 写 将客户端的数据提交到服务器，加密方式注册，用于注册信息

![image_1cqn5ejnfa7gkt313ac1n0ni9f1t.png-19.8kB](http://static.zybuluo.com/linyaonie/f6je0kqxppdrcg1m4y3fsuy1/image_1cqn5ejnfa7gkt313ac1n0ni9f1t.png)

 

# HTTP状态码

![image_1cqn5fltvvdrpuh1p351nfk170q2q.png-17.2kB](http://static.zybuluo.com/linyaonie/e91xd3e6zek76ys8oc98e10v/image_1cqn5fltvvdrpuh1p351nfk170q2q.png)

 

# 生产场景常见的状态吗及其对应的作用

![image_1cqn5h0kp1foq14j96gv1mspvqq4a.png-72kB](http://static.zybuluo.com/linyaonie/qfza6iczkgouanwqop549p2b/image_1cqn5h0kp1foq14j96gv1mspvqq4a.png)

 

# HTTP协议通信原理过程，整个通信原理的重要知识点有：

 

1. `用户访问网站的流程`
2. `DNS解析流程细节`
3. `建立TCP连接过程（TCP/IP三次握手原理知识）（11种状态）`
4. `发送HTTP报文及HTTP请求报文内容细节。`
5. `Web服务器响应客户端请求处理细节（网站集群架构细节）`
6. `响应HTTP报文及HTTP响应报文的细节`
7. `关闭TCP连接，涉及TCP/IP协议四次挥手原理`
8. `事实上，DNS解析原理，http协议原理，tcp/ip协议原理都是高薪面试的重点，是高级运维必备知识，这里对其中的重要知识点进行汇总，如下：`
9. ``
10. `http协议位于OSI模型中第7层应用层`
11. `http协议的重要应用是www服务。`
12. `用户上网流程，DNS解析原理流程`
13. `DNS解析获取的IP后，建立TCP连接，然后发送http请求细节和服务器响应细节。`
14. `HTTP请求报文与HTTP响应报文知识`
15. `到达HTTP服务后请求后端集群节点流程为Nginix-->fastcgi-->PHP-->(数据库，存储等)`
16. `TCP/IP协议三次握手和四次挥手原理。`

 

# 媒体类型

> 互联网上的数据有很多不同的数据类型，Web服务器会把通过Web传输的每个对象都打上名为MIME类型（MIME Type）的数据格式标签。最初涉及MIME（Multipurpose Internet Mail Extension 多用途因特网邮件扩展）是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。MIME在电子邮件系统中工作的非常好，后来，HTTP也支持了这个功能，用它来把数据描述并标记不同的数据内容类型。
>
> 当Web服务器响应HTTP请求时，会为每一个HTTP对象数据加一个MIME类型，当Web浏览器获取到服务器返回的对象时，会去查看相关的MIME类型，进行相应处理。
>
> MIME类型存在于HTTP响应豹纹的响应头部信息里，它是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

![image_1cqn6cg9u163m1srd1lpkedt1vmo3u.png-35.3kB](http://static.zybuluo.com/linyaonie/jajhvc8ayetgejux1lcyhu36/image_1cqn6cg9u163m1srd1lpkedt1vmo3u.png)

 

# 网页语言

> html语言：决定网页都有什么些什么内容 
> CSS语言：控制网页内容的位置和特效 
> JS语言=javascript：控制动作

 

# URL介绍

> 用户发起的请求，就叫用户发起了URL 
> 所谓的网址就是URL 
> 网址=域名+资源位置(URI) 
> URL=域名+URI
>
> URL，全称Uniform Resource Location，中文翻译为统一资源定位符，也被称为网页地址（网址）。如同在网络上的门牌，它是因特网上标准的资源唯一地址。通俗地说，URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户端和服务器程序上。采用URL可以用一种统一的格式来描述各种信息资源，包括文件，服务器的地址和目录等。严格的说，每个URL都是一个URI，它标识一个互联网资源，并指定对其进行操作或取得该资源的方法。

URL的格式由下列三部分组成：

> 第一部分是协议，例如：http 
> 第二部分是主机资源服务器IP地址或域名（端口号），例如：www.baidu.com 
> 第三部分是主机资源的具体地址，如目录和文件名等，例如：yunjisuan/index.html
>
> 提示： 
> 第一部分和第二部分之间用“://”符号隔开，第二部分和第三部分用"/"符号隔开。第一部分和第二部分是不可缺少的，第三部分可以省略。

 

# URI介绍

> URI，全称UnURI，全称Uniform Resource Identifier，中文翻译为统一资源标识符，是一个用于标识某一互联网资源名称的字符串。这个字符串在世界范围内唯一标识并定位某一个信息资源。互联网上每个可用的数据资源，如HTML，图片，视频等皆通过统一资源标识符进行定位。
>
> URL是URI命名机制的一个子集
>
>  iform Resource Identifier，中文翻译为统一资源标识符，是一个用于标识某一互联网资源名称的字符串。这个字符串在世界范围内唯一标识并定位某一个信息资源。互联网上每个可用的数据资源，如HTML，图片，视频等皆通过统一资源标识符进行定位。
>
> URL是URI命名机制的一个子集

 

# 静态网页资源

> 在网站设计中，纯粹HTML格式的网页（可以包含图片，视频，JS（前端功能实现），CSS（样式）等）通常被称为“静态网页”，早期的网站大多都是静态的。静态网页是相对于动态网页而言的，是指没有后台数据库，不含程序（如php，jsp，asp）和可交互的网页。

 

### 静态网页资源特点

> 静态网页资源的特点是，开发者编写的是什么，它显示的就是什么，一旦编写完成，就不会有任何改变。静态网页的维护和更新相对比较麻烦，每个不同的网页都需要单独编集更新，静态网页一般适用于更新较少的宣传展示型网站（例如：酒，家具，猪饲料等的宣传网站），是早期很多中小网站展示的形式。
>
> 静态网页资源的对应程序及资源文件的常见扩展名为：

 

1. `纯文本类程序或文件，如htm，html，xml，shtml，js，css等`
2. ``
3. `图片类文件或数据文档，如jpg，gif，png，bmp，txt，doc，ppt等`
4. ``
5. `视频类流媒体文件，如mp4，swf，avi，wmv，flv等`

 

### 静态网页资源重要的特征

 

1. `每个网页都有一个固定的URL地址，且URL一般以.html,.html,shtml等常见形式为后缀，而且地址中不含邮问号“？”或“&”等特殊符号。`
2. ``
3. `网页内容一经发布到网站服务器上，无论是否有用户访问，每个网页的内容都是保存在网站服务器文件系统上的，也就是说，静态网页是实实在在保存在服务器上的文件实体，每个网页都是一个独立的文件。`
4. ``
5. `网页内容是固定不变的，因此，容易被搜索引擎收录（容易被用户找到）（优点）`
6. ``
7. `网页没有数据库支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作的方式比较困难（缺点）`
8. ``
9. `网页的交互性较差，在程序功能实现方面有较大的限制（缺点）`
10. ``
11. `网页程序在用户浏览器端解析，如IE浏览器，程序解析效率很高，由于服务端不进行解析，并且不需要读取数据库，因此服务器端可以接受更多的并发访问。当客户端向服务器请求数据时，服务器直接把数据从磁盘文件系统上返回（不做任何解析），待客户端拿到数据后，在浏览器端解析展现出来（优点）`

> 网站静态页面的特点就相当于在餐馆吃火锅，餐馆把原材料和工具都给你准备好，你自己只需要涮着吃就行，不需要饭店大厨给你炒菜做菜了，因此，对于饭店来讲，服务顾客的效率大大提高了。而对于静态页面来讲就是不需要服务器端解析，因此提供网站方服务器的压力也大大减轻了。

 

### 静态网页语言

> 常见的静态网页语言有html，js，css，xml，shtml等。

 

### 静态网页的核心特点

> 程序在客户浏览器端解析，不读取后端数据库，因此性能和效率很高。
>
> 因为后端没有数据库支持，所以和用户的交互性较差，功能实现也很少。

 

### 静态网页的架构思想

> 在高并发，高访问量的场景下做架构优化，涉及的关键环节就是把动态网页转成静态网页，而不直接请求数据库和动态服务器，并且可以把静态内容推送到前端缓存（或CDN）中提供服务，这样就可以提升用户体验，节约服务器和维护成本。

 

# 动态网页资源

> 所谓的动态网页是与静态网页相对而言的，也就是说，动态网页的URL后缀不是.htm,.html,.shtml,.xml,.js,.css等静态网页的常见后缀扩展名形式，而是以.asp,.aspx,.php,.js,.do,.cgi等形式作为后缀的，并且一般在动态网页网址中会有标志性的符号--“？，&”，此外，在大多数情况下后端都需要有数据库支持等。

 

### 动态网页资源特点

> 1）网页扩展名后缀常见为：.asp,.aspx,.php,.jsp,.do,cgi等
>
> 2）网页一般以数据库技术为基础，大大降低了网站维护的工作量
>
> 3）采用动态网页技术的网站可以实现更多的功能，如用户注册，用户登录，在线调查，投票，用户管理，订单管理，发博文等等
>
> 4）动态网页并不是独立存在于服务器上的网页文件，当用户请求服务器上的动态程序时，服务器解析这些程序并可能读取数据库返回一个完整的网页内容。
>
> 5）动态网页中的“？”在搜索引擎的收录方面存在一定问题，搜索引擎一般不会从一个网站的数据库中访问全部网页，或者出于技术等方面的考虑，搜索蜘蛛一般不会去抓去网址中“？”后面的内容，因此在企业通过搜索引擎进行推广时，需要针对采用动态网页的网站做一定的技术处理（伪静态技术），以便适应搜索因穷的抓取要求。
>
> 6）程序在服务器端解析，这相当于顾客点餐，饭店厨师做饭做菜，耗时长，效率低。由于程序在服务端解析，因此，会消耗大量的CPU和内存，I/O等资源，并且多数还要读取数据库等服务，因此，其访问效率远不如静态网页，在服务端解析动态程序的服务常见的有PHP引擎，Java容器（tomcat,resin,jboss,weblogic）

 

### 有关动态网页的架构思想

> 一般来说，静态网页的性能效率是动态网页的10～30倍。且动态网站效率很差，并发能力也很低，在高并发场景中，应尽可能转换成静态网页提供服务。动态转静态几乎是所有高并发网站必备的架构方案思路，也是高级架构师的职责所在。
>
> 此外，动态转静态也要根据业务需求设计，例如，对于更新频繁的网站如果设计不好就可能会产生数据不一致的情况，即用户看到的数据不是网站最新的内容，而是静态的内容。

 

# 网站流量度量术语

 

### IP（internet Protocol）

> IP(独立IP)即Internet Protocol，这里指独立IP数，独立IP数是指不同IP地址的计算机访问网站时被计算的总次数。独立IP数是衡量网站流量的一个重要指标。一般一天内（00:00 - 24:00）相同IP地址的客户端访问网站页面只被计算为一次，记录独立IP的时间可为一天或一个月，目前通用的标准为“一天”。
>
> 假设有部分同学同时在某处的局域网中打开了www.baidu.com，请问对于百度来说网站是几个独立IP？答：是一个独立IP。这是因为，国内几乎所有的公司都是采用局域网共享上网的，即通过路由器NAT地址转换上网，每个计算机在局域网内的私有IP是不同的，但是在外网上，就必须都要由路由器把每个私网地址转换成了路由器接口的固定公网IP（多IP映射暂不考虑），所以说，对于网站来说一天内多个相同公司的IP的客户端访问计算为一个独立IP
>
> 再假设一个客户端用户通过ADSL等直接拨号上网，但是上网的时候偶尔掉线，一共重新拨号了3次（相近时间重新拨号IP相同的几率是极少的），然后每次都继续打开百度的网页地址，请问此时，网站独立IP数是多少？还是一个独立IP 
> 由此可见，通过独立iP数度量网站访问量，和实际的访问情况不是很匹配。国内的企业，学校大多数使用的NAT上网的，一个独立IP背后可能有数十上百个客户端访问。独立IP数虽然不是很准，但却是IT技术人员比较关心的一个衡量网站的指标。

 

### PV（Page View）

> PV（访问量）即Page View，中文翻译为页面浏览，即页面浏览器或点击量，不管客户端是不是相同，也不管IP是不是相同，用户每次访问一个网站页面都会被计算一个PV。
>
> PV的具体度量方法就是从客户浏览器发出一个对Web服务器的请求（Request），Web服务器接到这个请求后，将该请求对应的一个网页（Page）发送给浏览器，就产生一个PV。这里有一个问题，就是只要这个请求发送给了浏览器，无论这个页面是否完全打开（或下载完成），那么都是会被计数为1个PV（服务器日志），一般为了防止用户快速刷PV，很多网站把PV的统计程序放在页面的最下面。
>
> 用PV衡量网站时，PV数反映的是浏览某网站的页面数量，每刷新一次页面也算一次。因此，可以说PV数与来访用户的数量成正比，但PV数并不是真正的页面来访者数量，而是网站被访问的页面数量，因为一个来访者可能产生多个PV。

 

### UV(Unique Visitor)

> UV(独立访客)即Unique Visitor，同一台客户端（PC或移动端）访问网站被计算为一个访客。一天（00:00-24:00）内相同的客户端访问同一个网站只计算一次UV。UV一般是以客户端Cookie等技术作为统计依据的，实际统计会有误差。
>
> 考虑到一台客户端电脑可能会有多人使用的情况，因此，UV（独立访客）实际上并不一定是独立的自然人访问。 
> 1.http请求报文：浏览器版本，OS 
> 2.http响应报文：cookie（id）

 

# 并发连接

> 理解：网站服务器在单位时间内能够处理的最大连接数。

 

# 统计并发数的基本方法

> 统计当下时刻的linux的网络连接数并发，netstat -an|grep -i “est”|wc -l
>
> nginx web 层 active status

 

### 其他服务并发连接

> （1）QPS（Query Per Second）每秒查询率 
> 每秒查询率QPS是用于衡量一个特定的查询服务器在规定时间内所处理流量多少的标准。运维工作中，DNS系统以及数据库等服务的查询性能经常用每秒查询率来衡量。
>
> （2）IOPS（Input/Output Operations Per Second） 
> IOPS即每秒进行读写（I/O）操作的次数，多用于数据库等场合，衡量随机访问的性能。存储端的IOPS性能和主机端的I/O是不同的，IOPS是指存储每秒可接受多少次主机发出的访问，主机的一次I/O需要多次访问存储才可以完成。例如，主机写入一个最小的数据块，也要经过“发送写入请求，写入数据，收到写入确认”等三个步骤，也就是3个存储访问。

 

# 测试磁盘的存储性能？

> 连续的读写向磁盘中写入大的文件 
> dd if=/dev/zero of=/tmp/test01.bin bs=1K count=10000

 

# 有关网站度量Linux企业运维常见面试题

> 请问你们的网站并发是多少？
>
> 你们公司网站访问量是多少？怎么计算？
>
> 一定要理解IP，PV，并发量这3个点的知识，在回答时才能有的放失，这三个点的多少决定面试时说多大的架构，对于没有经验的新手不能在说有几万的PV时，还说数十台的集群架构，这样就乌龙了。
>
> 运维部分日志分析
>
> 开发在页面嵌入JS程序统计收集，分析
>
> 运营市场通过第三方公司提供的工具程序统计，例如：GA统计

 

# www服务软件介绍

 

### 常用来提供静态Web服务的软件

> Apache：这是中小型Web服务的主流，Web服务器中的老大哥。
>
> Nginx：大型网站Web服务主流，曾经Web服务器中的初生牛犊，现已长大。Nginx的分支tengine（http://tengine.taobao.org/）目前也在飞速发展。
>
> Lighttpd：这是一个不温不火的优秀的Web软件，社区不活跃，静态解析效率很高。在Nginx流行前，它是大并发静态业务的首选，国内百度贴吧，豆瓣等众多网站都有lighttpd奋斗的身影。

 

### 常用来提供动态服务的软件

> PHP（fastcgi）：大中小型网站都会使用，动态网页语言PHP程序的解析容器。它可配合Apache解析动态程序，不过，这里的PHP不是Fastcgi守护进程模式，而是mod_php5.so(module).也可配合Nginx解析动态程序，此时的PHP常用Fastcgi守护进程模式提供服务。
>
> tomcat:中小企业动态Web服务主流，互联网Java容器主流（如jsp，do）
>
> resin：大型动态Web服务主流，互联网Java容器主流（如jsp，do）
>
> IIS（internet information services）：微软Windows下的Web服务软件（asp，.aspx）

 

### www 静态程序服务软件apache

> Apache软件有几个重要的版本系列，分别为：Apache1.3，Apache2.0，Apache2.2，Apache2.4等，其中，APache1.3和Apache2.0系列已经成为过去时，官方的网站也看不见其踪影了，目前主流的Apache为2.2系列，正在向Apache2.4系列过渡阶段。如果没有特别要求，建议读者当下使用Apache2.2系列。 
> 官方地址：http://www.apache.org/

 

### www静态服务软件Nginx

> Nginx的版本只有一个系列，但是版本更新很快，仅仅半年就有数个版本，这也看出来社区的活跃程序。具体内容参见文档地址：http://www.nginx.org/以及http://www.nginx.org/en/docs/

 

### www 动态服务软件Resin

> Resin官方号称是世界上最快的Web服务，是大型动态Web服务主流，为互联网Java程序的解析容器，百度，人人都曾用过Resin 
> 目前企业用的较多的是3.1系列，正在向4.0过度

 

### www动态服务软件PHP

> PHP软件是大中小型网站程序前台页面开发的首选，存世开源软件众多，也是中小企业网站开发的首选，它是动态网页语言PHP程序的解析容器。PHP的版本系列有PHP5.2，PHP5.3，PHP5.4，PHP5.5，PHP5.6，其中最经典的版本为PHP5.2系列，企业应用的主流版本可以说是百花争艳。
>
> 值得注意的是PHP提供解析的方式，在配合Apache解析动态程序时，用的是mod_php5.so(module)模块的方式：在配合nginx解析动态程序时，常用Fastcgi守护进程模式提供服务。

#  tcp和ip协议

# TCP协议原理

TCP每发送一个报文段，就启动一个定时器，如果在定时器超时之后还没有收到ACK确认，就重传该报文。 如图所示，数据包由A的缓冲区发往B，B在收到数据包以后，回发一个ACK确认包给A，之后A将该数据包从缓冲区释放。因此，该数据包会一直缓存在A的缓冲区，直到一个ACK确认为止。 
![这里写图片描述](https://img-blog.csdn.net/20160328151746164)

在TCP/IP协议中，TCP协议提供可靠的面向连接的服务；三次握手（建立连接）和四次挥手（关闭连接）；使用**滑动窗口机制**进行流量控制； 

#### 三次握手的详细图解：


所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。如图1所示。 
![这里写图片描述](https://img-blog.csdn.net/20160328151734683)
图1 三次握手建立TCP连接的各状态 
（1）第一次握手：建立连接时，客户端A发送SYN包[SYN=1,seq=x]到服务器B，并进入SYN_SEND状态，等待服务器B确认。 
（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN，同时自己也发送一个SYN包，即SYN+ACK包[SYN=1,ACK=1,seq=y,ack=x+1]，此时服务器B进入SYN_RECV状态。 
（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK[ACK=1,seq=x+1,ack=y+1]，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据。 
**三次握手完成后**，客户端和服务器就建立了TCP连接。这时可以**调用accept函数获得此连接**。**三次握手的目的**是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换TCP 窗口大小信息。在socket编程中，**客户端执行connect()时，将会触发三次握手**。 
**四次挥手的详细图解** 
TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。TCP要保证在所有可能的情况下使得所有的数据都能够被投递，当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态 ，这能够保证所有的数据都被传输。 
![这里写图片描述](https://img-blog.csdn.net/20160328151930731)
图2 四次挥手关闭TCP连接的各状态 
（1）首先A B端的TCP进程都处于established状态， 当A的应用程序传送完报文段，就会去主动关闭连接。A会停止发送报文段（但是还会接收），并向B发送[FIN = 1,seq=u]数据，之后进入FIN-WAIT-1状态； 
（2）B接收到A发送的请求之后，会通知应用进程，A已经不再发送数据，同时B会向A发送ACK确认数据[ACK=1,seq=v,ack=u+1 ]，B进入CLOSE-WAIT状态，A接收到B发送的数据之后，A进入FIN-WAIT-2状态；此时A到B方的连接已经关闭了（即半连接状态）。 
（3）当B的应用进程发现自己也没有数据需要传送，B应用进程就会发出被动关闭的请求，B此时向A发送[FIN=1,ACK=1,seq=w,ack=u+1]数据，并且进入LAST-ACK状态； 
（4）A接收到B发送的数据之后，向B发送ACK确认数据[ACK =1,seq=u+1,ack=w+1]，进入TIME-WAIT状态，等待2MSL之后正常关闭连接进入CLOSED状态；B接收到A发送的确认之后进入CLOSED状态。B到A方的连接关闭！至此，TCP连接才真正全部关闭！ 

# 3几个问题

1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 
这是因为服务端的LISTEN状态下的SOCKET当收到客户端的SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 
2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 
这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到 ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于 LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的 ACK报文。 
3.TCP报文段 
![这里写图片描述](https://img-blog.csdn.net/20160328152021856)

TCP报文段也分为首部和数据两部分，首部默认情况下一般是20字节长度，但在一些需求情况下，会使用“可选字段”，这时，首部长度会有所增加。 

### 首部固定部分各字段的意义如下：

- **源端口和目的端口：**各占2个字节，分别写入源端口号和目的端口号。
- **序号：**占4个字节。序号使用mod![img](https://blog.csdn.net/xieyutian1990/article/details/24913027)运算。TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。故该字段也叫做“报文段序号”。
- **确认序号：**占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认序号=N,则表明：到序号N-1为止的所有数据都已正确收到。
- **数据偏移：**占4位，表示TCP报文段的首部长度。注意，“数据偏移”的单位是32位字（即以4字节长的字为计算单位）。故TCP首部的最大长度为60字节。
- **保留：**占6位，保留为今后使用，目前置为0；
- **窗口：**占2个字节。窗口值作为接收方让发送方设置其发送窗口的依据。
- **检验和：**占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP数据报一样，在计算检验和时，也要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与UDP用户数据报的伪首部一样，但要将伪首部第四个字段中的17 改为6（协议号），把第5字段中的UDP长度改为TCP长度。
- **紧急指针：**占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数。

TCP首部报文信息中，有一个状态控制码（Code，Control Flag），也叫标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下： 

*传输数据过程*TCP报文的首部格式中确认号的计算： 
确认号是期望收到对方下一个报文段的第一个数据字节的序号。 

**序列号等于前一个报文段的序列号与前一个报文段中数据字节的数量之和**。



##### TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。典型的TCP头部选项结构如图3-4所示。

![这里写图片描述](https://img-blog.csdn.net/20180112113455560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFzaHVubG9uZzE1ODM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

##### 选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息。常见的TCP选项有7种，如图3-5所示。

![这里写图片描述](https://img-blog.csdn.net/20180112113521071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFzaHVubG9uZzE1ODM2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## kind=0是选项表结束选项。



##### kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。

##### kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。

##### kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65?535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。

##### 和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。

##### kind=4是选择性确认（Selective Acknowledgment，SACK）选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。

##### kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。

##### kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。

4.在已经成功建立连接的TCP连接，在以下四种情况时会导致TCP产生严重错误，**发送RST包**： 
1、端口未打开 
2、请求超时 
3、提前关闭 4、在一个已关闭的socket上收到数据

# udp原理和tcp原理的区别

### 传输层的作用

1：提供面向连接或无连接的服务

2:    维护连接状态

3:对应用层数据进行分段和封装

4：实现多路复用

5:可靠地传输数据　　

6：执行流量控制

 #### 归纳总结

1： TCP和UDP通过端口号标识上层应用和服务

2:    TCP通过三次握手建立可靠连接

3:     TCP通过校验和进行差错校验，通过序列号、确认和超时重传机制实现可靠传输，通过滑动窗口实现流量控制

4:    UDP实现简单，资源占用少，实用性强，适用于可靠性高的网络和延迟敏感的用用

### 图文讲解

2.TCP的特点

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221214133-1903478840.png)

 

3.TCP/UDP端口号

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221419289-1617897935.png)

 

4.TCP连接的建立

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221438899-1794102022.png)

 

5.TCP连接的断开

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221514617-1868824159.png)

 

6.传输确认

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221535258-132487216.png)

 

7.超时重传

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221554930-612923205.png)

8.滑动窗口

![img](https://images2015.cnblogs.com/blog/795254/201704/795254-20170402221615820-1772148229.png)

# 页面显示的样子

res.writeHead(200, {"Content-Type":"text/html"});

改变text/后面的就可以改变

res.write();事泄入东西的



# get请求

	1:创建一个用于异步请求的对象
		var xhr = new XMLHttpRquest();


2.	设置异步请求的方式, 以及网址和参数
		xhr.open("GET","网址?参数列表");

3.	设置请求状态事件的处理函数
      	xhr.onreadystatechange = function(){
      		//	通过xhr.readyState 获取请求的状态.
      		//	状态值有五个:
      		//	0:	正在初始化
      		//	1:	请求正在发送
      		//	2:	请求发送完毕
      		//	3:	服务器正在响应
      		//	4:	响应完毕, 连接已断开
4.	判断事件发生时, 状态为4 .
      		if(xhr.readyState == 4){
5.	判断服务器的响应状态码(xhr.status) (200/404/500 等等)
      			if(xhr.status == 200){
      				//请求成功
6.	成功时, 可以通过xhr.responseText 接收响应体.
      			}else{
      				//请求失败, 一般是因为服务器BUG  或 用户网络问题.
      			}
      		}
      	}
7.	发送请求
      	xhr.send();

代码：

var http=require("http");
var url=require("url");
var qs=require("querystring");
http.createServer(function (req,res){
        if(req.method=="GET"){
        doget(req,res);
}else if(req.mothod=="POST"){
        dopost(req,res);

}else{
        res.end();

}
}).listen(1337,"127.0.0.1");
function doget(req,res){
         var obj=qs.parse(url.parse(req.url).query);
         console.log(obj);
         res.writeHead(200, {"Content-Type":"text/html"});
         res.write('<html>');
         res.write('<head>');
         res.write('<title>');
         res.write('</title>');
         res.write('</head>');
         res.write('<body>');
         res.write('<form method="get">');
         res.write('username:<input name="username">');
   res.write('password:<input name="password" type="password"><input type="submit">');
         res.write('</form>');
         res.write('</body>');
         res.write('</html>');
         res.end();

}
function dopost(req,res){
        res.write("success!");
        res.end();

}
console.log("Server running at http://127.0.0.1:1337/");

# post请求

1.	创建一个用于异步请求的对象
		var xhr = new XMLHttpRquest();

2.	设置异步请求的方式, 以及网址
		xhr.open("POST","网址");

3.	设置请求状态事件的处理函数
		xhr.onreadystatechange = function(){
			//	通过xhr.readyState 获取请求的状态.
			//	状态值有五个:
			//	0:	正在初始化
			//	1:	请求正在发送
			//	2:	请求发送完毕
			//	3:	服务器正在响应
			//	4:	响应完毕, 连接已断开

4.	判断事件发生时, 状态为4 .
			if(xhr.readyState == 4){
5.	判断服务器的响应状态码(xhr.status) (200/404/500 等等)
				if(xhr.status == 200){
					//请求成功
6.	成功时, 可以通过xhr.responseText 接收响应体.
				}else{
					//请求失败, 一般是因为服务器BUG  或 用户网络问题.
				}
			}
		}
7.	如果需要传递参数, 需要加入POST请求头:
		xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");
8.	发送请求
		xhr.send(参数列表);//参数列表的格式 与 GET请求? 后的参数列表格式一致.



var qs=require("querystring");
http.createServer(function (req,res){
        if(req.method=="GET"){
        doGet(req,res);
}else if(req.mothod=="POST"){
        doPost(req,res);

}else{
        res.end();

}
}).listen(1337,"127.0.0.1");
function doGet(req,res){
         res.writeHead(200, {"Content-Type":"text/html"});
         res.write('<html>');
         res.write('<head>');
         res.write('<title>');
         res.write('</title>');
         res.write('</head>');
         res.write('<body>');
         res.write('<form method="post">');
         res.write('username:<input name="username">');
   res.write('password:<input name="password" type="password"><input type="submit">');
         res.write('</form>');
         res.write('</body>');
         res.write('</html>');
         res.end();


}
function doPost(req,res){
        var formDate="";
        req.on('data',function(data){
           formDate+=data;
        });
        req.on('end',function(){
        var obj=qs.parse(formDate);
         res.end(obj.toString());
        })

}
console.log("Server running at http://127.0.0.1:1337/");

# 分开来写的

### post

var qs=require('querystring');
function doPost(req,res){
        var formDate='';
        req.on('data',function(data){
           formDate+=data;
        });
        req.on('end',function(){
        var obj=qs.parse(formDate);
         console.log(obj);
            res.end();
        })

}
exports.doPost=doPost;



### get

function doGet(req,res){
         res.writeHead(200, {"Content-Type":"text/html"});
         res.write('<html>');
         res.write('<head>');
         res.write('<title>');
         res.write('</title>');
         res.write('</head>');
         res.write('<body>');
         res.write('<form method="post">');
         res.write('username:<input name="username">');
   res.write('password:<input name="password" type="password"><input type="submit">');
         res.write('</form>');
         res.write('</body>');
         res.write('</html>');
         res.end();
}
exports.doGet = doGet;
~                            

### server

var http=require("http");
var url=require("url");
var qs=require("querystring");
var get =require('./httpGet');
var post =require('./httpPost');
http.createServer(function (req,res){
        if(req.method=="GET"){
        get.doGet(req,res);
}else if(req.mothod=="POST"){
        post.doPost(req,res);

}else{
        res.end();

}
}).listen(1337,"127.0.0.1");
console.log("Server running at http://127.0.0.1:1337/");





var net =require('net');
var server =net.createServer(function(socket){
 socket.write('Echo server\r\n');
 socket.pipe(socket);
});
server.listen(1337,'127.0.0.1');
~                                    

# 客户端

var net =require('net');
var clientList=[];
var server =net.createServer(function(socket){
 clientList.push(socket);
 socket.write('success\r\n');
 socket.on('data',function(data){
    console.log(data.toString());
   // socket.write(data);
    broadcast(data);
  });
 socket.on('end',function(){
 socket.write('end!');
  });
});
function broadcast(data){
   for(var i=0;i<clientList.length;i++){
   clientList[i].write(data);

   }
}
server.listen(1337,'127.0.0.1');
~                               

# 服务器

var net =require('net');
var hostname=process.argv[2];
var port=process.argv[3];
var client =net.connect({host:hostname,port:port},
  function(){
    console.log('connected to server');
        process.stdin.setEncoding('utf8');
        process.stdin.on('readable',function(){
            var chunk=process.stdin.read();
                if(chunk !==null){
                   client.write('data:' +chunk);
                }
        });
   });
client.on('data',function(data){
  console.log(data.toString());
  // client.end();
});

client.on('end',function(){
  console.log('disconnected from server');
});

# end与on 的其区别 

### end:结束并提交

### on :结束不提交                                               

# 处理多人聊天，一但有人退出服务器断开问题

### 使用shell启动脚本守护node


使用node来守护的话资源开销可能会有点大，而且也会略显复杂，OurJS直接在开机启动脚本来进程线程守护。 

如在debian中放置的 ourjs 开机启动文件： [/etc/init.d/ourjs](https://github.com/newghost/ourjs/blob/master/tools/ourjs) 

这个文件非常简单，只有启动的选项，守护的核心功能是由一个无限循环 while true; 来实现的，为了防止过于密集的错误阻塞进程，每次错误后间隔1秒重启服务 

 

```
WEB_DIR=＇/var/www/ourjs＇
WEB_APP=＇svr/ourjs.js＇

#location of node you want to use
NODE_EXE=/root/local/bin/node

while true; do
    {
        $NODE_EXE $WEB_DIR/$WEB_APP config.magazine.js
        echo "Stopped unexpected, restarting 

"
    } 2>> $WEB_DIR/error.log
    sleep 1
done
```

# 安装

sudo apt install -y aptitude
sudo aptitude search kchm
sudo aptitude install kchmviewer
安装chm阅读查看器，安装完后是个软件

# html中当前未用到的样式

### font:

font: 8pt/12pt georgia,palatino,times,serif;

font-style: normal;

font-variant-ligatures: normal;

font-variant-caps: normal;

font-variant-numeric: normal;

font-variant-east-asian: normal;

font-weight: normal;

font-family: georgia, palatino, times, serif;



### voice:

voice-family: "\"}\"";

voice-family: inherit;

text-decoration-line:underline;

# 关于定位的

### position:relative 绝对定位，在固定位置定死：

### position:absolute 相对定位，相对上一个div的：

### float 定位是在，你写的div里面浮动：

# 关于有序和无序清除数字或者点命令

### list  style-type:none

# 导航栏固定格式

```html
<div class="container">
    <div class="row">
     </div>
</div>
```

### 案例1: 合并来写

```html
<div class="container">
    <div class="row">
        <div class="col-md-4">col-md-4</div>
        <div class="col-md-4">col-md-4</div>
        <div class="col-md-4">col-md-4</div>
        <!-- 说明：每row行共12列，分个3div，每个div平占4列，即3个*4列=12列 -->
    </div>
    <div class="row">
        <div class="col-md-4">col-md-4</div>
        <div class="col-md-8">col-md-8</div>
        <!-- 说明：每row行共12列，分个2div，第1个div占4列，第2个div则占8列，即4列+8列=12列 -->
    </div>
    <div class="row">
        <div class="col-md-3">col-md-3</div>
        <div class="col-md-6">col-md-6</div>
        <div class="col-md-3">col-md-3</div>
        <!-- 说明：每row行共12列，分个3div，每1,3个div占3列，第2个div则占6列，即3列+6列+3列=12列 -->
    </div>
</div>
https://blog.csdn.net/mr_javascript/article/details/79677503
```



### 案例2：分开来写

```html
// container 容器
<div class="container"> 
        <div class="navbar-header">
          <a class="navbar-brand page-scroll" href="#page-		           top">Innova</a>
          <div class="phone"><span>Call Today</span>320-123-4321</div>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav navbar-right">
            <li class=""><a href="#about" class="page-scroll">About</a></li>  <!-- （1） -->
            <li class=""><a href="#services" class="page-scroll">Services</a></li> <!-- （2） -->
            <li class=""><a href="#portfolio" class="page-scroll">Projects</a></li>    <!-- （3） -->
            <li class=""><a href="#testimonials" class="page-scroll">Testimonials</a></li> <!-- （4） -->
            <li class=""><a href="#contact" class="page-scroll">Contact</a></li>                 <!-- （5） -->
          </ul>
        </div>
      </div>
// row 行内的 
<div id="about">
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-md-6"> <img src="/home/lei/下载/moban4149 (1)/img/2.jpg" class="img-responsive" alt=""> </div>
      <div class="col-xs-12 col-md-6">
        <div class="about-text">
          <h2>Who We Are</h2>
          <p>文本内容</p>
          <h3>标题</h3>
          <div class="list-style">
            <div class="col-lg-6 col-sm-6 col-xs-12">
              <ul>
                <li>Years of Experience</li>
                <li>Fully Insured</li>
                <li>Cost Control Experts</li>
                <li>100% Satisfaction Guarantee</li>
              </ul>
            </div>
            <div class="col-lg-6 col-sm-6 col-xs-12">
              <ul>
                <li>Free Consultation</li>
                <li>Satisfied Customers</li>
                <li>Project Management</li>
                <li>Affordable Pricing</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

```

# sass

$  代表的是自定义变量：

```
$highlight-color: #F90;
$highlight-border: 1px solid $highlight-color;
.selected {
  border: $highlight-border;
}

//编译后

.selected {
  border: 1px solid #F90;
}
```

-和 _ 表示的是分割：

```
$link-color: blue;
a {
  color: $link_color;
}

//编译后

a {
  color: blue;
}
```

#表示的是嵌套 ：<格式1>

```
#content {
  article {
    h1 { color: #333 }
    p { margin-bottom: 1.4em }
  }
  aside { background-color: #EEE }
}
 /* 编译后 */
#content article h1 { color: #333 }
#content article p { margin-bottom: 1.4em }
#content aside { background-color: #EEE }
```

#表示的是嵌套 ：<格式2>

```
#content {
  background-color: #f5f5f5;
  aside { background-color: #eee }
}
```

容器元素的样式规则会被单独抽离出来，而嵌套元素的样式规则会像容器元素没有包含任何属性时那样被抽离出来。

```
#content { background-color: #f5f5f5 }
#content aside { background-color: #eee }
```

&父选择器的标识符&;

```
#content aside {
  color: red;
  body.ie & { color: green }
}
/*编译后*/
#content aside {color: red};
body.ie #content aside { color: green }
```

# 子组合选择器和同层组合选择器：>、+和~;

```
article {
  ~ article { border-top: 1px dashed #ccc }
  > section { background: #eee }
  dl > {
    dt { color: #333 }
    dd { color: #555 }
  }
  nav + & { margin-top: 0 }
}
```

`sass`会如你所愿地将这些嵌套规则一一解开组合在一起：

```
article ~ article { border-top: 1px dashed #ccc }
article > footer { background: #eee }
article dl > dt { color: #333 }
article dl > dd { color: #555 }
nav + article { margin-top: 0 }
```

# 导入SASS文件;

使用`sass`的`@import`规则并不需要指明被导入文件的全名。你可以省略`.sass`或`.scss`文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的`sass`样式文件语法，在`sass`和`scss`语法之间随意切换。举例来说，`@import`"sidebar";这条命令将把`sidebar.scss`文件中所有样式添加到当前样式表中。

![img](https://www.sass.hk/images/p1.png)

# 混合器;

```
@mixin rounded-corners {
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}
```

然后就可以在你的样式表中通过`@include`来使用这个混合器，放在你希望的任何地方。`@include`调用会把混合器中的所有样式提取出来放在`@include`被调用的地方。如果像下边这样写：

```
notice {
  background-color: green;
  border: 2px solid #00aa00;
  @include rounded-corners;
}

//sass最终生成：
.notice {
  background-color: green;
  border: 2px solid #00aa00;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
```

@函数也就是方法 也就是定义方法的

%

# FILTER(处理请求：拦截后放行)

### Filter 处理请求的接口dofilter (有拦截和放行)

### 面相切面（AOP）

#### 相当于辣条 + 馒头思想；一块能吃，分开也能吃

####  什么是AOP

AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

AOP技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

**二、AOP核心概念**

**1、横切关注点**

对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点

**2、切面（aspect）**

类是对物体特征的抽象，切面就是对横切关注点的抽象

**3、连接点（joinpoint）**

被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器

**4、切入点（pointcut）**

对连接点进行拦截的定义

**5、通知（advice）**

所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类

**6、目标对象**

代理的目标对象

**7、织入（weave）**

将切面应用到目标对象并导致代理对象创建的过程

**8、引入（introduction）**



# 函数名称:	$.ajax

参数列表:	只有一个参数,  这个参数是一个规格对象, 描述Ajax请求的规格.

格式:
	$.ajax({
		url:"请求的网址",
		type:"GET或POST",
		async:"请求是否异步",//默认值为true , 表示异步请求
		data:"请求的参数列表",//格式与get请求?后的参数列表一致
		dataType:"TEXT或JSON",//服务器返回的数据类型.
		success:function(data){
			//当服务器响应的状态码在200-299之间时. 表示成功,此函数执行
			//参数data 是服务器回复的响应体.
			//当dataType值为TEXT时, data是string类型的
			//当dataType值为JSON时, data是对象.
		},
		error:function(){
			//当服务器响应的状态码不再200-299之间时, 表示失败, 此函数执行
		}
	});

## 两个函数的格式一致的 , get函数用于get请求, post函数用于post请求

函数名称: $.get 或 $.post
参数列表:
		参数1.	url	: string类型	 请求网址
		参数2.	data: string类型		请求的参数 , 格式与get请求后?的格式一致
		参数3.	success: function类型的参数 ,成功时处理的函数.
		参数4.	dataType:  string类型 响应的数据类型, TEXT或JSON

## 在不创建Vue实例的情况下,  使用全局ajax函数.

GET请求格式:
	Vue.http.get("请求地址",["请求的参数"]).then(success,error);
POST请求格式:
	Vue.http.post("请求地址",["请求的参数"],{"emulateJSON":true}).then(success,error);

# 出现参数的情况下.该如何去写

1. 请求地址:	string类型的字符串. 相对路径即可.

2.	GET请求的参数:	请求的参数以对象的方式传递. 例如: 我们需要传递username和password, 可以按照如下格式编写:
		var user = new Object();
		user.username = "xxx";
		user.password = "xxx";
		var obj = new Object();
		obj.params = user;
		//传递obj对象即可

		或者:
		{
			params:{
				username:"xxx",
				password:"xxx"
			}
		}

3.	POST请求的参数: 请求的参数以对象的方式传递. 例如: 我们需要传递username和password, 可以按照如下格式编写:
		var user = new Object();
		user.username = "xxx";
		user.password = "xxx";
		
		或者:
		{
			username:"xxx",
			password:"xxx"
		}

4.	success函数 与 error函数的编写
		success函数 与 error函数编写方法完全一致;
		格式:
			function(res){
		
	
		}
		
		res(响应对象)的常用属性:
			-	url	:	响应的网址
			-	body:	响应体 , 如果响应的内容是JSON格式的, 得到的是对象, 如果不是JSON,得到的是string
			-	ok	:	boolean值, 当响应码为200-299之间时, 为true
			-	status	:	响应码: 200 , 404 ,500 等等
		-	statusText : 响应码对应的文字, 例如: 200对应的是ok 
		
		res(响应对象)的常用函数:
			-	text()	:	以字符串形式, 返回响应体
			-	json()	:	以对象形式, 返回响应体
			-	blob()	:	以大数据二进制形式, 返回响应体.
	# GET

1.	创建一个用于异步请求的对象
	

​	var xhr = new XMLHttpRquest();
​	
2. 设置异步请求的方式, 以及网址和参数
   	xhr.open("GET","网址?参数列表");

3. 设置请求状态事件的处理函数
   	xhr.onreadystatechange = function(){
      		//	通过xhr.readyState 获取请求的状态.
      		//	状态值有五个:
      		//	0:	正在初始化
      		//	1:	请求正在发送
      		//	2:	请求发送完毕
      		//	3:	服务器正在响应
      		//	4:	响应完毕, 连接已断开

4. 判断事件发生时, 状态为4 .
   		if(xhr.readyState == 4){

5. 判断服务器的响应状态码(xhr.status) (200/404/500 等等)
   			if(xhr.status == 200){
      				//请求成功

6. 成功时, 可以通过xhr.responseText 接收响应体.
   			}else{
      				//请求失败, 一般是因为服务器BUG  或 用户网络问题.
      			}
      		}
      	}

7. 发送请求
   	xhr.send();



#  POST

1.	创建一个用于异步请求的对象
		var xhr = new XMLHttpRquest();
2.	设置异步请求的方式, 以及网址
		xhr.open("POST","网址");
3.	设置请求状态事件的处理函数
		xhr.onreadystatechange = function(){
			//	通过xhr.readyState 获取请求的状态.
			//	状态值有五个:
			//	0:	正在初始化
			//	1:	请求正在发送
			//	2:	请求发送完毕
			//	3:	服务器正在响应
			//	4:	响应完毕, 连接已断开
4.	判断事件发生时, 状态为4 .
			if(xhr.readyState == 4){
5.	判断服务器的响应状态码(xhr.status) (200/404/500 等等)
				if(xhr.status == 200){
					//请求成功
6.	成功时, 可以通过xhr.responseText 接收响应体.
				}else{
					//请求失败, 一般是因为服务器BUG  或 用户网络问题.
				}
			}
		}
7.	如果需要传递参数, 需要加入POST请求头:
		xhr.setRequestHeader("content-type","application/x-www-form-urlencoded");
8.	发送请求
		xhr.send(参数列表);//参数列表的格式 与 GET请求? 后的参数列表格式一致.



# ES6

下面的命令在项目目录中，安装 Babel。

```bash
$ npm install --save-dev @babel/core
```

### 配置文件.babelrc

Babel 的配置文件是`.babelrc`，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。

该文件用来设置转码规则和插件，基本格式如下。

```javascript
{
  "presets": [],
  "plugins": []
}
```

`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。

```bash
# 最新转码规则
$ npm install --save-dev @babel/preset-env

# react 转码规则
$ npm install --save-dev @babel/preset-react
```

然后，将这些规则加入`.babelrc`。

```javascript
  {
    "presets": [
      "@babel/env",
      "@babel/preset-react"
    ],
    "plugins": []
  }
```

注意，以下所有 Babel 工具和模块的使用，都必须先写好`.babelrc`。



### 命令行转码

Babel 提供命令行工具`@babel/cli`，用于命令行转码。

它的安装命令如下。

```bash
$ npm install --save-dev @babel/cli
```

基本用法如下。

```bash
# 转码结果输出到标准输出
$ npx babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ npx babel example.js --out-file compiled.js
# 或者
$ npx babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ npx babel src --out-dir lib
# 或者
$ npx babel src -d lib

# -s 参数生成source map文件
$ npx babel src -d lib -s
```

### babel-node

`@babel/node`模块的`babel-node`命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。

首先，安装这个模块。

```bash
$ npm install --save-dev @babel/node
```

然后，执行`babel-node`就进入 REPL 环境。

```bash
$ npx babel-node
> (x => x * 2)(1)
2
```

`babel-node`命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件`es6.js`，然后直接运行。

```bash
# es6.js 的代码
# console.log((x => x * 2)(1));
$ npx babel-node es6.js
2
```

### @babel/register 模块

`@babel/register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js`、`.jsx`、`.es`和`.es6`后缀名的文件，就会先用 Babel 进行转码。

```bash
$ npm install --save-dev @babel/register
```

使用时，必须首先加载`@babel/register`。

```bash
// index.js
require('@babel/register');
require('./es6.js');
```

然后，就不需要手动对`index.js`转码了。

```bash
$ node index.js
2
```

需要注意的是，`@babel/register`只会对`require`命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。

### babel API

如果某些代码需要调用 Babel 的 API 进行转码，就要使用`@babel/core`模块。

```javascript
var babel = require('@babel/core');

// 字符串转码
babel.transform('code();', options);
// => { code, map, ast }

// 文件转码（异步）
babel.transformFile('filename.js', options, function(err, result) {
  result; // => { code, map, ast }
});

// 文件转码（同步）
babel.transformFileSync('filename.js', options);
// => { code, map, ast }

// Babel AST转码
babel.transformFromAst(ast, code, options);
// => { code, map, ast }
```

配置对象`options`，可以参看官方文档http://babeljs.io/docs/usage/options/。

下面是一个例子。

```javascript
var es6Code = 'let x = n => n + 1';
var es5Code = require('@babel/core')
  .transform(es6Code, {
    presets: ['@babel/env']
  })
  .code;

console.log(es5Code);
// '"use strict";\n\nvar x = function x(n) {\n  return n + 1;\n};'
```

上面代码中，`transform`方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。

### @babel/polyfill

Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如`Iterator`、`Generator`、`Set`、`Map`、`Proxy`、`Reflect`、`Symbol`、`Promise`等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。

举例来说，ES6 在`Array`对象上新增了`Array.from`方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用`babel-polyfill`，为当前环境提供一个垫片。

安装命令如下。

```bash
$ npm install --save-dev @babel/polyfill
```

然后，在脚本头部，加入如下一行代码。

```javascript
import '@babel/polyfill';
// 或者
require('@babel/polyfill');
```

Babel 默认不转码的 API 非常多，详细清单可以查看`babel-plugin-transform-runtime`模块的[definitions.js](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js)文件。

### 浏览器环境

Babel 也可以用于浏览器环境，使用[@babel/standalone](https://babeljs.io/docs/en/next/babel-standalone.html)模块提供的浏览器版本，将其插入网页。

```html
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
// Your ES6 code
</script>
```

注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。

Babel 提供一个[REPL 在线编译器](https://babeljs.io/repl/)，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。

## Traceur 转码器

Google 公司的[Traceur](https://github.com/google/traceur-compiler)转码器，也可以将 ES6 代码转为 ES5 代码。

### 直接插入网页

Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。

```html
<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
<script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
<script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
<script type="module">
  import './Greeter.js';
</script>
```

上面代码中，一共有 4 个`script`标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。

注意，第四个`script`标签的`type`属性的值是`module`，而不是`text/javascript`。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有`type=module`的代码编译为 ES5，然后再交给浏览器执行。

除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。

```javascript
<script type="module">
  class Calc {
    constructor() {
      console.log('Calc constructor');
    }
    add(a, b) {
      return a + b;
    }
  }

  var c = new Calc();
  console.log(c.add(4,5));
</script>
```

正常情况下，上面代码会在控制台打印出`9`。

如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。

```javascript
<script>
  // Create the System object
  window.System = new traceur.runtime.BrowserTraceurLoader();
  // Set some experimental options
  var metadata = {
    traceurOptions: {
      experimental: true,
      properTailCalls: true,
      symbols: true,
      arrayComprehension: true,
      asyncFunctions: true,
      asyncGenerators: exponentiation,
      forOn: true,
      generatorComprehension: true
    }
  };
  // Load your module
  System.import('./myModule.js', {metadata: metadata}).catch(function(ex) {
    console.error('Import failed', ex.stack || ex);
  });
</script>
```

上面代码中，首先生成 Traceur 的全局对象`window.System`，然后`System.import`方法可以用来加载 ES6。加载的时候，需要传入一个配置对象`metadata`，该对象的`traceurOptions`属性可以配置支持 ES6 功能。如果设为`experimental: true`，就表示除了 ES6 以外，还支持一些实验性的新功能。

### 在线转换

Traceur 也提供一个[在线编译器](http://google.github.io/traceur-compiler/demo/repl.html)，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。

上面的例子转为 ES5 代码运行，就是下面这个样子。

```javascript
<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
<script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
<script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
<script>
$traceurRuntime.ModuleStore.getAnonymousModule(function() {
  "use strict";

  var Calc = function Calc() {
    console.log('Calc constructor');
  };

  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {
    return a + b;
  }}, {});

  var c = new Calc();
  console.log(c.add(4, 5));
  return {};
});
</script>
```

### 命令行转换

作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。

```bash
$ npm install -g traceur
```

安装成功后，就可以在命令行下使用 Traceur 了。

Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的`calc.js`为例。

```bash
$ traceur calc.js
Calc constructor
9
```

如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。

```bash
$ traceur --script calc.es6.js --out calc.es5.js
```

上面代码的`--script`选项表示指定输入文件，`--out`选项表示指定输出文件。

为了防止有些特性编译不成功，最好加上`--experimental`选项。

```bash
$ traceur --script calc.es6.js --out calc.es5.js --experimental
```

命令行下转换生成的文件，就可以直接放到浏览器中运行。

### Node 环境的用法

Traceur 的 Node 用法如下（假定已安装`traceur`模块）。

```javascript
var traceur = require('traceur');
var fs = require('fs');

// 将 ES6 脚本转为字符串
var contents = fs.readFileSync('es6-file.js').toString();

var result = traceur.compile(contents, {
  filename: 'es6-file.js',
  sourceMap: true,
  // 其他设置
  modules: 'commonjs'
});

if (result.error)
  throw result.error;

// result 对象的 js 属性就是转换后的 ES5 代码
fs.writeFileSync('out.js', result.js);
// sourceMap 属性对应 map 文件
fs.writeFileSync('out.js.map', result.sourceMap);
```

## let 命令

### 基本用法

ES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。

### 暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```javascript
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。

“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

## 两种情况

```javascript
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
```

上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于“死区”。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。

```javascript
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

另外，下面的代码也会报错，与`var`的行为不同。

```javascript
// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
```

上面代码报错，也是因为暂时性死区。使用`let`声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量`x`的声明语句还没有执行完成前，就去取`x`的值，导致报错”x 未定义“。

ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 块级作用域与函数声明

函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

```javascript
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
```

上面两种函数声明，根据 ES5 的规定都是非法的。

但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

```javascript
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
```

上面代码在 ES5 中运行，会得到“I am inside!”，因为在`if`内声明的函数`f`会被提升到函数头部，实际运行的代码如下。

```javascript
// ES5 环境
function f() { console.log('I am outside!'); }

(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
```

ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于`let`，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？

```javascript
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```

上面的代码在 ES6 浏览器中，都会报错。

原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在[附录 B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。

- 允许在块级作用域内声明函数。
- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作`let`处理。

根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于`var`声明的变量。上面的例子实际运行的代码如下。

```javascript
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```javascript
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

```javascript
// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}
```

上面代码中，第一种写法没有大括号，所以不存在块级作用域，而`let`只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。

函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。

```javascript
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```

## const 命令

### 基本用法

`const`声明一个只读的常量。一旦声明，常量的值就不能改变。

```javascript
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

上面代码表明改变常量的值会报错。

`const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。

```javascript
const foo;
// SyntaxError: Missing initializer in const declaration
```

上面代码表示，对于`const`来说，只声明不赋值，就会报错。

`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

```javascript
if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
```

`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

```javascript
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
```

上面代码在常量`MAX`声明之前就调用，结果报错。

`const`声明的常量，也与`let`一样不可重复声明。

```javascript
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
```

### const本质

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

下面是另一个例子。

```javascript
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。

如果真的想将对象冻结，应该使用`Object.freeze`方法。

```javascript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```javascript
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。

#### 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```javascript
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

## Map

### 含义和基本用法

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

```javascript
const data = {};
const element = document.getElementById('myDiv');

data[element] = 'metadata';
data['[object HTMLDivElement]'] // "metadata"
```

上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。

为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```javascript
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false
```

上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。

上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```javascript
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```

上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。

`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

```javascript
const items = [
  ['name', '张三'],
  ['title', 'Author']
];

const map = new Map();

items.forEach(
  ([key, value]) => map.set(key, value)
);
```

事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。

```javascript
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```

上面代码中，我们分别使用 Set 对象和 Map 对象，当作`Map`构造函数的参数，结果都生成了新的 Map 对象。

如果对同一个键多次赋值，后面的值将覆盖前面的值。

```javascript
const map = new Map();

map
.set(1, 'aaa')
.set(1, 'bbb');

map.get(1) // "bbb"
```

上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。

如果读取一个未知的键，则返回`undefined`。

```javascript
new Map().get('asfddfsasadf')
// undefined
```

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```javascript
const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
```

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

```javascript
const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
```

上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

```javascript
let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
```

# 点赞原理

import React from 'react'
class BOttom extends React.Component {
	constructor(props){
		super(props)
		this.state={
			likes:0
		}
		//this.A=this.A.bind(this)
	}

	A(){
		this.setState({
			likes:++this.state.likes
		})
		}
	
	render(){
		return (
			<div ClassName="likes-button-component">
				<button 
				type="button" 
				ClassName="btn btn-outline-primary  btn-lg"
				onClick={()=> { this.A()}}
				>
	
					点{this.state.likes}
				</button>
			</div>
	
		)
	}
}
export default BOttom



# 时间表原理

import React from 'react'  //倒入依赖关系
class DD extends React.Component{      //建立一个类继承这个依赖
	constructor(props){          // constructor函数
		super(props)
		this.state = {   //创建一个state  
			date:new Date()    //new date 表示当前的时间
		}
	}
	componentDidMount() {   //时间的周期函数 
		this.timer=setInterval(() => {    //一个健值对的表现
			this.setState({   
				date:new Date()  //当前时间每隔一秒进行递增
			})
		},1000)
	}
	componentWillUnmount(){
		clearInterval(this.timer)
	}
	render() {   //  与面所需要展示的定西
		return(    //  展示的东西内容

			<div className="digital-clock-component jumbotron">
				<h1>{this.state.date.toLocaleTimeString()}</h1>
			</div>  //整个div中的<h1>里面的内容就是把时间展示在<h1>标签了里面，运用toLocaleTimeString拼接成这种固定和格式
​		)
​	}
}

export default DD  // 导出

# React的使用

000；pwd 查看你在那个目录下

000：sudo chown  文件名 ：关于文件权限问题 必须在你文件的目录下

000；sudo chown  *              ：关于文件权限问题 必须在你文件的目录下

1：sudo npm install -g create-react-app      安装

2；create-react-app mooc-new   建立文件

3： npm start   启动线程

4；打开vim   在src目录下建立自己的js文件    

5；在src目录下打开index,js 文件 把自己的文件引入其中。

6:关于文件用 sublime保存时需要输入密码的问题    命令：sudo chmod 777 -R 文件名

7:{ }的使用

# ES6 箭头函数 

  1：function expression function () { ... } 

 2：() => { ... }

1等同与2

# 构造函数 super

constructor(props) {

 super(props);

 }

state 通过使用 this 绑定在类上。因此，你可以在整个组件中访问到 state。例如它可以用 在 render() 方法中。此前你已经在 render() 方法中映射一个在组件外定义静态列表。现 在你可以在组件中使用 state 里的 list 了

const list = [ 

{ 

title: 'React', 

url: 'https://facebook.github.io/react/', 

author: 'Jordan Walke',

num_comments: 3, 

points: 4, 

objectID: 0, 

}, ... 

]; 

class App extends Component {

constructor(props) { 

super(props); 

this.state = { 

list: list, 

}; 

} ... 

} 

state 通过使用 this 绑定在类上。因此,你可以在整个组件中访问到 state。例如它可以用
在 render() 方法中。此前你已经在 render() 方法中映射一个在组件外定义静态列表。现
在你可以在组件中使用 state 里的 list 了。
src/App.js
class App extends Component {
...
render() {
return (

<div className="App">
{this.state.list.map(item =>
<div key={item.objectID}>
<span>
<a href={item.url}>{item.title}</a>
</span>
<span>{item.author}</span>
<span>{item.num_comments}</span>
<span>{item.points}</span>
</div>
)}
</div>
);
}
}

# React如何绑定事件

this.事件名=this.事件名.bind(this)

事件名，声明在return里面，然后绑定事件，







# filter 函数

你可以通过 JavaScript 内置的 filter 方法来删除列表中的一项。fitler 方法以一个函数作为输
入。这个函数可以访问列表中的每一项,因为它会遍历整个列表。通过这种方式,你可以
基于过滤条件来判断列表的每一项。如果该项判断结果为 true,则该项保留在列表中。否
则将从列表中过滤掉。另外,好的一点是这个方法会返回一个新的列表而不是改变旧列
表。它遵循了 React 中不可变数据的约定。

onDismiss(id) {
const updatedList = this.state.list.filter(function isNotId(item) {
return item.objectID !== id;
});
}
在下一步中,你可以抽取函数并将其传递给 filter 函数。

onDismiss(id) {
function isNotId(item) {
return item.objectID !== id;
}
const updatedList = this.state.list.filter(isNotId);
}
另外,可以通过使用 ES6 的箭头函数让代码更简洁。http://blog.csdn.net/jiongyi1
React 基础

onDismiss(id) {
const isNotId = item => item.objectID !== id;
const updatedList = this.state.list.filter(isNotId);
}
你甚至可以内联到一行内完成,就像在按钮的 onClick 事件处理器做的一样,但如此会损
失一些可读性。

# bind 的使用

这个函数被绑定到组件上,因此再次成为一个类方法,你必定义方法并 bind 它。

class App extends Component {
constructor(props) {
super(props);
this.state = {
list,
};
this.onSearchChange = this.onSearchChange.bind(this);
this.onDismiss = this.onDismiss.bind(this);
}
onSearchChange() {
...
}
...
}
在元素中使用监听时,你可以在回调函数的签名中访问到 React 的合成事件。

# 轮播图

import React from 'react';     //倒入依赖
import logo from './logo.svg'; //倒入这个logo
import './App.css';            //倒入app》css文件

import img1 from './img/77.jpg';  //建立图片
import img2 from './img/31.jpg';  //建立图片
import img3 from './img/30.jpg';  //建立图片
import img4 from './img/1.jpg';   //建立图片
import img5 from './img/2.png';   //建立图片
import img6 from './img/3.png';  //建立图片


class App extends React.Component{   //创建一个类
  constructor(props){   // 算是一种格式
    super(props)        //格式
    this.state={        //绑定这个state
      imgArr: [img1, img2, img3,img4,img5,img6],   //在state里面建立一个数组
      imgIndex: 0,       //下标
    }
  }
/*周期函数*/
  componentDidMount(){            // 渲染之后的第二部
    setInterval(this.spanRightCLick, 4000);   //定义一个时间周期
  }
/*左点击按钮*/
  spanLeftClick = () => {            //点击按钮  使用的是箭头函数 相当于function
        let {imgArr, imgIndex} = this.state; //定义imgarr 和imgindex  并绑定在state上面
        let imgNum = imgArr.length;   //定义这个state里面的数组imgarr 的长度为 imgnum
        imgIndex -= 1;       //指定下标每次减一
        if(imgIndex < 0){    //判断下标是否小于0
          imgIndex = imgNum -1;   // 当数组里面下标=数组长度减一时 
        }
        this.setState({imgIndex});   //渲染开始 也就是更新，就是从心开始播放
    };
/*有点击按钮*/
    spanRightCLick = () => {    //点检按钮
        let {imgArr, imgIndex} = this.state;  // 定义imgarr和imgindex绑定在state上
        let imgNum = imgArr.length;  //定义哦imgnum等于state里面的imgarr数组的长度
        imgIndex += 1;    //让下标imgindex每次加一
        if(imgIndex >= imgNum){ //当数组的下标大于或等于数组的长度时，回到下标为0的位置时重新开始开始更新
          imgIndex = 0;
        }
        this.setState({imgIndex}); //再次更新
    };
/*小园点*/
    liClick = (key) => { 
       let imgIndex= key ;
       this.setState({imgIndex});
    };
/*鼠标移入*/

hoverStop = ()=>{
        let that = this.bannerSwiper.$el[0] // 实例的container的dom节点

        that.addEventListener("mouseenter", () => {
            this.bannerSwiper.autoplay.stop()
            that.addEventListener("mousemove", () => {
            })
        })
        that.addEventListener("mouseleave",()=>{
            this.bannerSwiper.autoplay.start()
        })
}



/*遍历val和key    val是值   key是健*/
/*//进行三目运算*/
    render(){   //render里面的就是页面作展示的

        let {imgArr, imgIndex} = this.state;  
        return(
            <div className={'App'}>
                <div className={"content"}>
                    <img src={imgArr[imgIndex]} className={"img"} alt=""/>  
                    <div className={"span"}>
                        <p className={"left-span"} onClick={this.spanLeftClick}>{'<'}</p>   
                        <p className={"right-span"} onClick={this.spanRightCLick}>{'>'}</p>  
                    </div>
                    <ul className={"ul"}>    
                        {
                            imgArr.map((val, key) => {     
                                return (
                                    <li className={imgIndex == key ? "lis" : "li"}  key={key}  onClick={() => this.liClick(key)}>{}</li>  
                                );
                            })
                        }
                    </ul>
                </div>
                
            </div>








        );
    }
}
export default App