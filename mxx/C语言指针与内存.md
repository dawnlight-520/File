

## C语言指针与内存

#### 一 ：指针

main.c

```
#include <stdio.h>

void change(int *a,int *b)  // *表示指针
{
        int tmp=*a;
        *a=*b;
        *b=tmp;
}
int main()
{
        int a=123;
        int b=456;
        change(&a,&b);   //&表示取地址符号
        printf("num a=%d\nnum b=d%\n",a,b);
}

命令：
cc main.c -o main.out && ./main.out
输出：
//num a=456
//num b=123

```

#### 二：gdb调试工具

main2.c    //未用指针的版本

```
#include <stdio.h>

void change(int a,int b)  // *表示指针
{
        int tmp=a;
        a=b;
        b=tmp;
}
int main()
{
        int a=123;
        int b=456;
        change(a,b);   //&表示取地址符号
        printf("num a=%d\nnum b=%d\n",a,b);
}
```

```
调试过程：
gdb ./main2.out        //调试main2.out
(gdb) list                     //列出源代码
(gdb) start   //Temporary breakpoint 1, main () at main2.c:11   断点位置11行
(gdb) p a      //   $1 = 0         打印a的值
(gdb) n         //12		int b=456;       跳到下一行即12行
(gdb) p a     //$2 = 123     再次打印a
(gdb) p b    //$3 = 0     打印b的值
(gdb) n      //13		change(a,b);    跳到下一行准备执行函数change
(gdb) p a   //$4 = 123      此时的a变量值
(gdb) p b   //$5 = 456     此时的b变量值
(gdb) l      // 查看此行后面内容
(gdb) s  //change (a=123, b=456) at main2.c:5    查看change函数内容，
               //    5		int tmp=a;        此时传递了a,b变量的值
(gdb) n  //  6		a=b;       执行下一行
(gdb) p a  //$6 = 123       此时的a变量值
(gdb) p b  //$7 = 456        此时的b变量值
(gdb) bt              // 查看函数堆栈（各个函数堆起来的）
     //#0  change (a=123, b=456) at main2.c:6   编号0的是change函数
     //#1  0x000055555555468e in main () at main2.c:13  编号1是main函数在13行调用
(gdb) p a  //$8 = 123    此时a值为函数change里面的a值
(gdb) f 1     //  切换到函数堆栈编号为1的函数
         //#1  0x000055555555468e in main () at main2.c:13
         //13		change(a,b);
(gdb) f 0    //   切换到函数堆栈编号为0的函数
        //#0  change (a=456, b=123) at main2.c:8
        //8	}
(gdb) n    //执行到最后一行时，结果如下，change函数并为成功达到我们预期效果，
//num a=123
//num b=456     a 和 b的值并为被交换
//15	}
(gdb) q //退出调试程序
原因分析：a和b只是局部变量，并没有指向，所以change函数传参时不会改变a和b的值      来传递
```

```
调试main.c的输出文档main.out：
gdb ./main.out       
(gdb) l                  
(gdb) start
(gdb) n
		//13		change(&a,&b);   
(gdb) s             //查看change函数内容
       //change (a=0x7fffffffdf80, b=0x7fffffffdf84) at main.c:5  
       //此时a和b都表示一个堆栈地址，传递时只传递地址
       //5		int tmp=*a;     下一行内容
(gdb) n           //运行到最后时，a和b的值发生交换
		//num a=456
		//num b=123
		//15	}
原因分析：加上*符号后，在*a和*b传递时，只传递栈地址，而不会传递具体数值，发生改变的只是a/b变量的地址交换，从而使a/b的值发生交换
```

#### 三  数据表示方法

##### 	1 计算机中二进制：

​		高电位：1   			 低电位：0

32位操作系统只能使用4G内存：

32位表示有32根地址总线，总共可以存储2^32个字节

即 2^10 * 2^10 * 2^10* 2^2字节

​	=1024 * 1024 * 1024*4字节

​	=1024*1024 * 4k字节

​	=1024*4 M字节

​	=4G字节

#####     2  内存分布  64位操作系统为例

48-64位为     系统内核

高位段			栈内存   存放第一个运行的程序  如：main函数等等

中位段			自由分配内存

低位段			堆内存 

低位段			数据段  声明的一些全局变量或者常量  

 										const int i；//常量    int global；//全局变量								

低位段			代码段 代码编译后的二进制数据加载到内存中

内存的操作：一般是操作系统来统筹规划

##### 3 变量和指针的本质

​	当前程序运行的状态被记录在栈内存中

​	变量的本质：变量名只是一个标识符，一个代号，变量的本质是内存空间；

​    指针的本质：指针保存的是变量的内存地址；指针的本质就是地址；

##### 4 操作系统对内存的管理

​		堆栈段：

　　1. 为函数内部的局部变量提供存储空间。

　　2. 进行函数调用时，存储“过程活动记录”。

​         3  用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入		堆栈

​        4 GCC会对内存变量分配进行优化：同一种变量类型会放到一块

​	64位计算机：指针占8位字节，变量占4位字节

```
一般把源代码编译完成为目标文件的代码就存在代码段；调用的函数指针的顺序就存放在栈内存，可以理解为栈的先进后出就是函数的调用的顺序；打印函数内部变量在代码段的存储位置：首先要用bt 显示你的栈内存顺序，再用f + 编号，进去你想打印变量所在的函数里面，再用p+ &变量名字，即可打印
```



##### 5 函数栈及数据段内存		

​		栈的特点：先进后出

​		数据段/代码段越往后声明的地址越大

​		栈越往后声明的地址越小，栈顶向下分配

​		静态变量在每个函数间都不互相影响，是独立变量。一个函数内的静态变量不管		函数运行多少次都在同一位置改动

##### 6 函数指针与指针指向的数据访问

​	函数指针格式： 返回值类型 (*变量名)(形参列表);

​	int quadraate(int a);是一个函数  

​	int （*pquadrate)(int a)=&quadrate;则是指向这个函数的指针  

​	int s=(*pquadrate)(a)可以调用函数

 	一个指针变量* q    不加*号：P q  取出自己地址中存储的值（一个地址），

​	加*号：P *q  取出指向地址中存储的值。

​	在内存里面会在编译时归纳排列，栈内存记录函数活动，代码段记录指令，数据记录申明

```
&*p：取变量a的地址（先进行*运算，*p相当于变量a，再进行&运算，&*p就相当于取变量a的地址）
*&p：取变量a所在地址的值（先进行&运算，&a相当于取变量a的地址，在执行*运算，*&p相当于取变量a所在地址的值）
```

#### 四   字符串与数组                    

##### 	1  数组申明的内存排列

​			在程序中，使用一个未声明变量的地址，改地址里面的值是随机的。C语言没有对地址的合法性进行检查

​			程序中声明的同一种变量在内存中连续排列

​			数组长度为常量，每一次定义的数组空间是固定的，声明的地址空间连续排放

​			x/3d 0x7ffffffffffffde14  从0x7ffffffffffffde14开始按10进制输出3个地址的内容，间隔4字节

```
gdb命令：x（打印内存值）/3（输出3个值）d（十进制显示） 0xffffff（开始地址）
```

​		 指针变量其实代表的是地址，加*表示取这个地址的值

​		p=&a后，获取了a的地址，p++时就是对一个十六进制的地址进行自加运算。

​		指针是动态数组； 		

```
#include <stdio.h>
int main()
{
        int a=3;
        int b=2;
        int array[2];
        array[0]=1;
        array[1]=10;
        array[2]=100;
        int *p=&a;
        int i;
        for(i=0;i<6;i++){
                printf("*p=%d\n",*p);
                p++;
        }
        printf("---------------------\n");
        p=&a;
        for(i=0;i<6;i++){
                printf("p[%d]=%d\n",i,p[i]);
        }
}
//*** stack smashing detected ***: <unknown> terminated
//已放弃 (核心已转储)
//mx@mx-ThinkPad-T420:~/c$ cc m.c -fno-stack-protector    解决办法
*p=3
*p=1
*p=2
*p=24583168
*p=32765
*p=-924518928
---------------------
p[0]=3
p[1]=1
p[2]=2
p[3]=24583156
p[4]=32765
p[5]=-924518928

0x7fffffffdf64:	3	0	2	-8344
0x7fffffffdf74:	32767	1431651824	1	10
0x7fffffffdf84:	100	-1087199744

```

##### 2  指针运算

```
指针数组和数组指针的区别：

数组指针（也称行指针）
定义 int (*p)[n];
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

在32 位系统下任何类型的指针永远是占4 个字节。即数组指针永远占4个字节。

数组与指针的不同在于数组是地址常量，而指针是地址变量
```

```
1.出现的*p=&a和p=&a

请注意第一次时 int *p 是指针声明 =&a 这是赋值。第二次的 p=&a 也是赋值 但是p前面没有加* 因为已经声明过了 除了声明地方之外的*p 意义为：取p这个指针变量所指向的地址中的值

2.p++：指针偏移，运行效率高

3.p+3与*p+3区别：前者是把现指针向下移动三格，后者是对指针所指地址的变量进行操作（数学运算加3）
```

##### 3  字符数组与指针字符串

```
#include <stdio.h>
int main()
{
        char str[]="hello";
        char *str2="world";
        char str3[10];
        printf("input the value \n");
        scanf("%s",str2);
        printf("str is %s\n",str);
        printf("str2 is %s\n",str2);
        printf("str3 is %s\n",str3);
}

```

​		字符串是以'/000'结束的 堆、栈内存中的内容是以更改的，代码段内存中的内容不允许修改。 实例： char *str = "apple"; scanf("%s",str); 这是错误的，因为str指向的是代码段内存中的内容，该内容不能进行修改

##### 4 深入理解

​		指针：int *p; *p  表示所指向的内存空间的值; 

​					p   是所指向内存空间的内存首地址; 

​					&p 是指p指针变量在内存中的地址;

字符串在遇到\0时就会停止不会执行后面的 

数组赋值时不要溢出 会覆盖其他地址甚至其他数据 数组和数组地址不是连续的 会空几个地址 

数组其实就是连续的地址 比如可以用for循环挨个打印元素

 在char数组里 \0也是一个元素 在字符串中是隐藏的元素

 在单个字符元素时要以‘\0’结尾 

数组和指针的差别 数组的开始地址不能改变 但可以改变他指向的地址的内容 而指针可以改变;









