# TCP/IP协议、HTTP原理和长连接

## 一. HTTP协议 *****

```
TCP/IP协议集中的子协议 .
一个传输层网络协议, 超文本传输协议 .

特点:
    1.  简单快速的传输协议 ,支持多种不同的数据提交方式. 例如: GET/POST
    2.  数据在传输时, 数据类型与大小是无限制的.
    3.  无连接协议 , 每一次连接 处理一次客户端请求, 服务器进行响应后, 立即断开连接
    4.  无状态协议 , 服务器在处理客户端的请求时, 没有记忆能力.
```

#### **1. HTTP协议与TCP/IP协议的关系**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。  IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。

---

#### 2. 如何理解HTTP协议是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

---

#### 3. 什么是长连接、短连接？

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

---

#### 3.1. TCP连接

当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。

经典的三次握手建立连接示意图：
![img](https://mccdn.qcloud.com/static/img/da079414fde193f4d790c72a719eba78/image.jpg)

![img](https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231325729-1747734402.png)

经典的四次握手关闭连接示意图：
![img](https://mccdn.qcloud.com/static/img/4e7b6439145e3db6c0a2ff62eec24322/image.jpg)

![img](https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231344745-1817753534.jpg)

#### 3.2. TCP短连接

模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

---

#### 3.3. TCP长连接

我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。

- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。

- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。

- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

  ---

#### 4. 长连接和短连接的优点和缺点

**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户**请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

由上可以看出，**长连接**可以**省去较多的TCP建立和关闭的操作，减少浪费，节约时间**。对于频繁请求资源的客户来说，较适用长连接。不过这里**存在一个问题**，**存活功能的探测周期太长**，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，**Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候**，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

#### **长连接短连接操作过程**

```
短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接
```

#### **什么时候用长连接，短连接？** 　　

**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

　　而像WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

 

#### http和socket之长连接和短连接区别

http://www.jianshu.com/p/b68d2b26f5f4

 

#### HTTP 的长连接和短连接

http://blog.jobbole.com/104108/

 

#### HTTP持久连接

https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5

 

#### 长连接

http://baike.baidu.com/view/2831907.htm

---

#### 5. HTTP协议的组成部分 *****

```
HTTP协议由两部分:
    1.  请求 : 客户端寻找服务器 索要数据的过程.
    2.  响应 : 服务器接收到客户端的请求后, 回复数据的过程.

请求由四部分组成:
    1.  请求头
            由一个个的键值对组成 , 用于描述客户端的信息.
    2.  请求体
            由一个个的键值对组成, 存储的是POST请求的请求数据.
            GET请求 不存在请求体.
    3.  请求空行
            在协议中, 请求头部与请求体之间的一行空白符
    4.  请求行
            由一个个的键值对组成, 描述的是请求的相关信息: 请求方式, 请求地址, 以及协议版本 等等

响应由三部分组成:
    1.  响应头
            由一个个的键值对组成 , 用于描述服务器的信息.    
    2.  响应体
            响应的内容 , 通常是一个HTML文件的内容.
    3.  响应行
            由一个个的键值对组成, 描述的是响应的相关信息: 服务器协议版本 ,响应状态码, 以及响应成功或失败的提示.
```

---

#### 6. Node.js 的 require 方法中的文件查找策略如下：

 由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：

![img](https://www.runoob.com/wp-content/uploads/2014/03/nodejs-require.jpg)

---

#### 7. 创建服务器

```
var http = require('http');
http.createServer(function (request, reponse){
        //发送HTTP头部
        //HTTP 状态值：200 ：ok
        //内容类型：text/plain
        response.writeHead(200,{'content-Type':'text/plain'});
        //发送响应数据‘’
        response.end('发送内容\n');

}).listen(8888);
console.log('Server running at http://127.0.0.0:8888/');
```

**分析Node.js 的 HTTP 服务器：**

-  第一行请求（require）Node.js 自带的  http  模块，并且把它赋值给  http 变量。
-  接下来我们调用 http 模块提供的函数：  createServer  。这个函数会返回 一个对象，这个对象有一个叫做  listen  的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。 

### 二. TCP三次握手和四次挥手

TCP有6种标示:SYN(建立联机) ACK(确认) PSH(传送) FIN(结束) RST(重置) URG(紧急) 

#### 1、TCP三次握手             

![img](https://images2018.cnblogs.com/blog/1090617/201802/1090617-20180225222433180-286295310.png)

 **第一次握手**

   客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。

 **第二次握手**

   TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。

 **第三次握手**

   TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。

TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。

**思考：为什么要三次握手呢，有人说两次握手就好了**

举例：已失效的连接请求报文段。

  client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。

 

#### 2、TCP数据的传输过程

 建立连接后，两台主机就可以相互传输数据了。如下图所示：

![img](https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116110315863-1316196878.png)

 **1）**主机A初始seq为1200,滑动窗体为100,向主机B传递数据的过程。

 **2）**假设主机B在完全成功接收数据的基础上,那么主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。因此按如下的公式确认 Ack 号：

​    Ack号 = Seq号 + 传递的字节数 + 1 （这是在完全接受成功的情况下）

 **3）**主机A获得B传来的ack(1301)后,开始发送seq为1301,滑动窗体为100的数据。
    ......

与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。上面说了，主机B完全成功接收A发来的数据才是这样的,如果存在丢包该如何。

 下面分析传输过程中数据包丢失的情况，如下图所示：

 ![img](https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116110625814-795901602.png)

​		上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。

 上面也只是一种可能,比如数据1250丢失,那么Ack返回的就是1250,具体的可以详细看下博客：[【TCP协议】（1）---TCP协议详解](https://www.cnblogs.com/qdhxhz/p/10267932.html),这里面滑动窗口有说明。

 

####  3、TCP的四次挥手          

![img](https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190116111104366-175362855.png) 

**第一次挥手** 

  TCP发送一个**FIN(结束)**，用来关闭客户到服务端的连接。

  客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），

此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

**第二次\**挥手\****

  		服务端收到这个FIN，他发回一个**ACK(确认)，**确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。

  		服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号eq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

​		客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

**第三次\**挥手\****

   服务端发送一个**FIN(结束)**到客户端，服务端关闭客户端的连接。

   服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，

此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次\**挥手\****

   客户端发送**ACK(确认)**报文确认，并将确认的序号+1，这样关闭完成。

   客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时

TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 

服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

思考：那么为什么是4次挥手呢？

为了确保数据能够完成传输。

  	 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

​		可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.

​		因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到

FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能

发送FIN报文，因此不能一起发送。故需要四步**挥手**。

思考:客户端突然挂掉了怎么办？

  		正常连接时，客户端突然挂掉了，如果没有措施处理这种情况，那么就会出现客户端和服务器端出现长时期的空闲。解决办法是在服务器端设置保活计时器，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。若服务器超过2小时没收到客户的信息，他就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。 

#### 4、SYN（洪水）攻击

背景

   	初始化连接的 SYN 超时问题Client发送SYN包给Server后挂了，Server回给Client的SYN-ACK一直没收到Client的ACK确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让Server将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的SYN连接队列耗尽，让正常的连接无法得到处理。

  	 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。

什么是 SYN 攻击

   	 SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器

需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。

如何检测 SYN 攻击？

   	检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的

netstats 命令来检测 SYN 攻击。

如何防御 SYN 攻击？

   	SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

   缩短超时（SYN Timeout）

   时间增加最大半连接数

   过滤网关防护SYN

   cookies技术 

####  5、TCP和UDP的区别    

 我这里简单列举几个，因为我还没有研究UDP这个协议。

 1、基于连接与无连接;UDP是无连接的，即发送数据之前不需要建立连接

 2、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付

​    ，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。

 5、TCP对系统资源要求较多，UDP对系统资源要求较少。

### 三. **UDP协议**

UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。

由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。

UDP传输数据被限制在64K以内。

![img](https://img2018.cnblogs.com/blog/1501588/201901/1501588-20190110140027466-1150140805.png)

### 四.  聊天室搭建

#### server端:

```
var net = require('net');
var clientList = [];
var server = net.createServer(function(socket){
        clientList.push(socket);
        socket.write('succes \r\n');
        socket.on('data',function(data){
                console.log(data.toString());
        //      socket.write(data);
                broadcast(data);
        });
        socket.on('end',function(){
                clientList = [];
                //socket.write('end');
        });
});
function broadcast(data){
        for(var i=0;i<clientList.length;i++){
                clientList[i].write(data);
        }
}
server.listen(1337, '127.0.0.1');

```

#### client端:

```
var net = require('net');
var hostname = process.argv[2];//得到IP地址
var port = process.argv[3];//得到端口号
var client = net.createConnection({host:hostname, port:port},
        function(){//连接监听成功
                console.log('connected to server');
                process.stdin.setEncoding('utf-8');
                process.stdin.on('readable',function(){
                        var chunk = process.stdin.read();
                        if(chunk != null){
                                client.write('data:' + chunk);
                        }
                });
        });
client.on('data',function(data){
        console.log(data.toString());
        //client.end();
});
client.on('end',function(){
        console.log('disconnected from server');
});

```

